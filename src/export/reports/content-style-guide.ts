/**
 * Content Style Guide Generator
 * Produces separate markdown document covering voice/tone, capitalization, CTA hierarchy, and error grammar
 * Complements Brand DNA Report (which covers design tokens and components)
 */

import type {
  ContentStyleResult,
  CapitalizationPattern,
  CTACharacteristics,
} from '../../types/content-style.js';
import { generateTable, heading, bold } from './markdown-utils.js';

export interface ContentStyleGuideParams {
  contentResult: ContentStyleResult;
  metadata: {
    sourceUrl: string;
    crawlDate: string;
  };
}

/**
 * Generate Content Style Guide markdown
 * Separate standalone document covering content patterns (not design tokens)
 */
export function generateContentStyleGuide(params: ContentStyleGuideParams): string {
  const { contentResult, metadata } = params;
  const sections: string[] = [];

  // Header with metadata
  sections.push(heading('Content Style Guide', 1));
  sections.push('');
  sections.push(`> Extracted from ${metadata.sourceUrl} on ${metadata.crawlDate}`);
  sections.push(`> Based on ${contentResult.totalSamples} text samples analyzed`);
  sections.push('');

  // Voice & Tone section
  sections.push(heading('Voice & Tone', 2));
  sections.push('');
  sections.push(generateVoiceToneSection(contentResult));
  sections.push('');

  // Capitalization Rules section
  sections.push(heading('Capitalization Rules', 2));
  sections.push('');
  sections.push(generateCapitalizationSection(contentResult));
  sections.push('');

  // CTA Hierarchy section
  sections.push(heading('CTA Hierarchy', 2));
  sections.push('');
  sections.push(generateCTAHierarchySection(contentResult));
  sections.push('');

  // Error Message Grammar section
  sections.push(heading('Error Message Grammar', 2));
  sections.push('');
  sections.push(generateErrorGrammarSection(contentResult));
  sections.push('');

  // Footer
  sections.push('---');
  sections.push('*Generated by UIUX-Mirror*');
  sections.push('*See also: brand-dna-report.md for design tokens and components*');

  return sections.join('\n');
}

/**
 * Generate Voice & Tone section
 */
function generateVoiceToneSection(contentResult: ContentStyleResult): string {
  if (contentResult.voicePatterns.length === 0) {
    return 'No voice patterns detected.';
  }

  const sections: string[] = [];

  // Find primary voice pattern (highest confidence)
  const primary = contentResult.voicePatterns.reduce((best, current) =>
    current.confidence > best.confidence ? current : best
  , contentResult.voicePatterns[0]);

  // Primary voice pattern
  sections.push(bold('Primary voice pattern:'));
  sections.push(`- Tone: ${primary.tone}`);
  sections.push(`- Tense: ${primary.tense}`);
  sections.push(`- Perspective: ${primary.perspective}`);
  sections.push(`- Confidence: ${getConfidenceLevel(primary.confidence)}`);
  sections.push('');

  // Examples (show up to 5)
  if (primary.examples.length > 0) {
    sections.push(bold('Examples:'));
    const exampleSlice = primary.examples.slice(0, 5);
    for (const example of exampleSlice) {
      sections.push(`> "${example}"`);
    }
    sections.push('');
  }

  // Additional voice patterns (if multiple detected)
  if (contentResult.voicePatterns.length > 1) {
    sections.push(bold('Additional voice patterns:'));
    sections.push('');

    const headers = ['Tone', 'Tense', 'Perspective', 'Confidence', 'Examples'];
    const rows: string[][] = [];

    for (const pattern of contentResult.voicePatterns.slice(1)) {
      const exampleCount = pattern.examples.length;
      const exampleStr = exampleCount > 0 ? `${exampleCount} samples` : 'No examples';
      rows.push([
        pattern.tone,
        pattern.tense,
        pattern.perspective,
        getConfidenceLevel(pattern.confidence),
        exampleStr
      ]);
    }

    sections.push(generateTable(headers, rows));
    sections.push('');
  }

  return sections.join('\n');
}

/**
 * Generate Capitalization Rules section
 */
function generateCapitalizationSection(contentResult: ContentStyleResult): string {
  if (contentResult.capitalizationPatterns.length === 0) {
    return 'No capitalization patterns detected.';
  }

  const sections: string[] = [];

  // Table of patterns by context
  const headers = ['Context', 'Style', 'Examples', 'Confidence'];
  const rows: string[][] = [];

  for (const pattern of contentResult.capitalizationPatterns) {
    const contexts = pattern.contexts.join(', ');
    const exampleStr = pattern.examples.slice(0, 3).join('; ');
    const confidenceStr = getConfidenceLevel(pattern.confidence);

    rows.push([contexts, pattern.style, exampleStr, confidenceStr]);
  }

  sections.push(generateTable(headers, rows));
  sections.push('');

  // Rule summary (extract most common patterns by context)
  sections.push(bold('Rule Summary:'));
  const contextMap = extractContextRules(contentResult.capitalizationPatterns);
  for (const [context, style] of Object.entries(contextMap)) {
    sections.push(`- ${context}: ${style}`);
  }
  sections.push('');

  return sections.join('\n');
}

/**
 * Extract context-specific capitalization rules
 */
function extractContextRules(patterns: CapitalizationPattern[]): Record<string, string> {
  const rules: Record<string, string> = {};

  // Group patterns by context
  const contextGroups = new Map<string, typeof patterns>();

  for (const pattern of patterns) {
    for (const context of pattern.contexts) {
      if (!contextGroups.has(context)) {
        contextGroups.set(context, []);
      }
      contextGroups.get(context)!.push(pattern);
    }
  }

  // For each context, pick highest confidence style
  for (const [context, contextPatterns] of contextGroups.entries()) {
    const best = contextPatterns.reduce((best, current) =>
      current.confidence > best.confidence ? current : best
    , contextPatterns[0]);

    rules[context] = best.style;
  }

  return rules;
}

/**
 * Generate CTA Hierarchy section
 */
function generateCTAHierarchySection(contentResult: ContentStyleResult): string {
  if (contentResult.ctaHierarchy.length === 0) {
    return 'No CTA hierarchy patterns detected.';
  }

  const sections: string[] = [];

  // Table of CTA levels
  const headers = ['Level', 'Visual Treatment', 'Usage Contexts', 'Examples', 'Frequency'];
  const rows: string[][] = [];

  for (const cta of contentResult.ctaHierarchy) {
    const visualDesc = describeVisualTreatment(cta.characteristics);
    const contexts = cta.characteristics.usageContexts.join(', ') || 'general';
    const exampleTexts = cta.examples.slice(0, 3).map(e => e.text).join('; ');
    const frequency = cta.frequency.toString();

    rows.push([cta.level, visualDesc, contexts, exampleTexts, frequency]);
  }

  sections.push(generateTable(headers, rows));
  sections.push('');

  // Visual guide with detailed descriptions
  sections.push(bold('Visual Guide:'));
  for (const cta of contentResult.ctaHierarchy) {
    const desc = describeVisualTreatmentDetailed(cta.characteristics);
    sections.push(`- ${cta.level}: ${desc}`);
  }
  sections.push('');

  return sections.join('\n');
}

/**
 * Describe visual treatment (brief)
 */
function describeVisualTreatment(chars: CTACharacteristics): string {
  const parts: string[] = [];

  if (chars.hasBackground) {
    parts.push('solid background');
  }
  if (chars.hasBorder) {
    parts.push('border');
  }
  if (chars.fontWeight && parseInt(chars.fontWeight) >= 600) {
    parts.push('bold text');
  }

  return parts.join(', ') || 'text only';
}

/**
 * Describe visual treatment (detailed)
 */
function describeVisualTreatmentDetailed(chars: CTACharacteristics): string {
  const parts: string[] = [];

  if (chars.hasBackground && chars.backgroundColor) {
    parts.push(`solid ${chars.backgroundColor} background`);
  } else if (chars.hasBackground) {
    parts.push('solid background');
  }

  if (chars.hasBorder && chars.borderColor) {
    parts.push(`${chars.borderColor} border`);
  } else if (chars.hasBorder) {
    parts.push('border only');
  }

  if (chars.textColor) {
    parts.push(`${chars.textColor} text`);
  }

  if (chars.fontWeight) {
    const weightNum = parseInt(chars.fontWeight);
    if (weightNum >= 600) {
      parts.push('bold weight');
    } else if (weightNum <= 400) {
      parts.push('regular weight');
    }
  }

  if (!chars.hasBackground && !chars.hasBorder) {
    parts.push('transparent background');
  }

  return parts.join(', ') || 'minimal styling';
}

/**
 * Generate Error Message Grammar section
 */
function generateErrorGrammarSection(contentResult: ContentStyleResult): string {
  if (contentResult.errorPatterns.length === 0) {
    return 'No error patterns detected.';
  }

  const sections: string[] = [];

  // Find primary error pattern (highest frequency)
  const primary = contentResult.errorPatterns.reduce((best, current) =>
    current.frequency > best.frequency ? current : best
  , contentResult.errorPatterns[0]);

  sections.push(bold('Primary pattern:') + ` ${primary.structure} with ${primary.tone} tone`);
  sections.push('');

  // Table of all patterns
  const headers = ['Structure', 'Tone', 'Examples', 'Suggests Action?', 'Frequency'];
  const rows: string[][] = [];

  for (const pattern of contentResult.errorPatterns) {
    const exampleStr = pattern.examples.slice(0, 2).join('; ');
    const suggestsStr = pattern.suggestsAction ? 'Yes' : 'No';
    const frequency = pattern.frequency.toString();

    rows.push([pattern.structure, pattern.tone, exampleStr, suggestsStr, frequency]);
  }

  sections.push(generateTable(headers, rows));
  sections.push('');

  // Common prefixes
  if (primary.commonPrefixes.length > 0) {
    sections.push(bold('Common prefixes:') + ` ${primary.commonPrefixes.join(', ')}`);
    sections.push('');
  }

  // Recommendations
  sections.push(bold('Recommendations:'));
  sections.push(`- Use ${primary.structure} format for consistency`);
  sections.push(`- Maintain ${primary.tone} tone across all error messages`);
  if (primary.suggestsAction) {
    sections.push('- Include corrective action suggestions');
  } else {
    sections.push('- Consider adding corrective action suggestions to improve UX');
  }
  sections.push('');

  return sections.join('\n');
}

/**
 * Get confidence level label
 */
function getConfidenceLevel(confidence: number): string {
  if (confidence >= 0.6) {
    return 'high';
  }
  if (confidence >= 0.3) {
    return 'medium';
  }
  return 'low';
}
