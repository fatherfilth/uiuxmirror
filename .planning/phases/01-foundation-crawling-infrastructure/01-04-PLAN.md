---
phase: 01-foundation-crawling-infrastructure
plan: 04
type: execute
wave: 3
depends_on: ["01-01", "01-02", "01-03"]
files_modified:
  - src/extractors/color-extractor.ts
  - src/extractors/typography-extractor.ts
  - src/extractors/spacing-extractor.ts
  - src/extractors/custom-properties-extractor.ts
  - src/extractors/shared/style-utils.ts
  - src/extractors/shared/index.ts
autonomous: true

must_haves:
  truths:
    - "Color extractor captures background, text, border, and accent colors with semantic grouping"
    - "Typography extractor captures font families, sizes (px-normalized), weights, line-heights"
    - "Spacing extractor captures margin, padding, gap values with px normalization"
    - "CSS custom property extractor reads :root variables and maps to token categories"
    - "All extractors attach evidence (selector, computedStyles) to every token"
  artifacts:
    - path: "src/extractors/color-extractor.ts"
      provides: "Color palette extraction with semantic categorization"
      exports: ["extractColors"]
    - path: "src/extractors/typography-extractor.ts"
      provides: "Typography scale extraction"
      exports: ["extractTypography"]
    - path: "src/extractors/spacing-extractor.ts"
      provides: "Spacing scale extraction with base unit detection"
      exports: ["extractSpacing"]
    - path: "src/extractors/custom-properties-extractor.ts"
      provides: "CSS custom property extraction and categorization"
      exports: ["extractCustomProperties"]
    - path: "src/extractors/shared/style-utils.ts"
      provides: "Shared utilities for computed style extraction"
      exports: ["getComputedStyleValue", "getAllVisibleElements", "parseColorToHex", "parseSizeToPixels"]
  key_links:
    - from: "src/extractors/color-extractor.ts"
      to: "src/extractors/shared/style-utils.ts"
      via: "uses getAllVisibleElements and parseColorToHex"
      pattern: "getAllVisibleElements|parseColorToHex"
    - from: "src/extractors/color-extractor.ts"
      to: "src/types/tokens.ts"
      via: "returns ColorToken[]"
      pattern: "ColorToken"
    - from: "src/extractors/color-extractor.ts"
      to: "src/types/evidence.ts"
      via: "attaches TokenEvidence to each token"
      pattern: "TokenEvidence"
---

<objective>
Implement the first four token extractors: colors (TOKEN-01), typography (TOKEN-02), spacing (TOKEN-03), and CSS custom properties (TOKEN-04).

Purpose: These are the most fundamental design tokens that every website has. Color, typography, and spacing form the backbone of any design system. CSS custom properties provide the site's own token vocabulary. Together they cover the most commonly-referenced design decisions.

Output: Four extractor functions that accept a Playwright Page and return typed token arrays with full evidence attached. Plus shared utilities for computed style access.
</objective>

<execution_context>
@C:/Users/Karl/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Karl/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@C:/Users/Karl/UIUX-Mirror/.planning/PROJECT.md
@C:/Users/Karl/UIUX-Mirror/.planning/phases/01-foundation-crawling-infrastructure/01-RESEARCH.md
@C:/Users/Karl/UIUX-Mirror/.planning/phases/01-foundation-crawling-infrastructure/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create shared style extraction utilities</name>
  <files>src/extractors/shared/style-utils.ts, src/extractors/shared/index.ts</files>
  <action>
Create common utilities used by all extractors to avoid code duplication.

src/extractors/shared/style-utils.ts:

1. getAllVisibleElements(page: Page): Promise<Array<{ selector: string; tagName: string; role: string | null; computedStyles: Record<string, string> }>>
   - Execute page.evaluate() that:
     a. Queries all elements: document.querySelectorAll('*')
     b. Filters to visible elements only (getBoundingClientRect width > 0 AND height > 0)
     c. Limits to first 500 elements to avoid memory issues on complex pages
     d. For each element, build a unique selector:
        - Prefer: element.id ? `#${id}` : build from tagName + nth-child path
        - Use a simple CSS path builder: traverse parentNode building "tag:nth-child(n)" segments
     e. Get computedStyles for relevant properties only (not ALL properties -- too expensive):
        - Colors: backgroundColor, color, borderColor, outlineColor
        - Typography: fontFamily, fontSize, fontWeight, lineHeight, letterSpacing
        - Spacing: marginTop, marginRight, marginBottom, marginLeft, paddingTop, paddingRight, paddingBottom, paddingLeft, gap, rowGap, columnGap
        - Layout: borderRadius, boxShadow, zIndex, width, height
        - Motion: transitionDuration, transitionTimingFunction, animationDuration, animationTimingFunction, animationName
     f. Return array of { selector, tagName, role (getAttribute('role')), computedStyles }
   - This runs as a SINGLE page.evaluate() call to avoid multiple round-trips

2. parseColorToHex(cssColor: string): string | null
   - Convert rgb(r, g, b), rgba(r, g, b, a), hsl(), hsla(), named colors to #rrggbb hex
   - Use the `color` npm library for conversion
   - Return null for transparent (rgba(0,0,0,0)) or invalid values
   - Normalize to lowercase hex

3. parseSizeToPixels(cssValue: string, baseFontSize: number = 16): number | null
   - Parse "16px" -> 16, "1rem" -> 16, "1.5em" -> 24 (using baseFontSize), "0" -> 0
   - Return null for auto, inherit, normal, or unparseable values
   - Handle calc() by returning null (too complex for v1)

4. buildSelector(element: Element): string
   - Helper used inside page.evaluate
   - If element has id, return `#${id}`
   - Otherwise build path: e.g. "body > div:nth-child(2) > main > h1"
   - Limit depth to 5 levels to keep selectors manageable

5. filterBrowserDefaults(value: string, property: string): boolean
   - Return false if value is a known browser default for that property
   - Known defaults: color: 'rgb(0, 0, 0)' for most elements, backgroundColor: 'rgba(0, 0, 0, 0)', fontSize: '16px' on body
   - This is a heuristic filter -- err on the side of including (false = exclude, true = include)
   - For v1, only filter out rgba(0,0,0,0) backgrounds and 'normal' letter-spacing/line-height

src/extractors/shared/index.ts -- Barrel export of all shared utilities.
  </action>
  <verify>Run `npx tsc --noEmit` -- should compile with zero errors.</verify>
  <done>Shared extraction utilities provide: batch element scanning with computed styles, color normalization to hex, size normalization to px, selector generation, and browser default filtering</done>
</task>

<task type="auto">
  <name>Task 2: Implement color and typography extractors</name>
  <files>src/extractors/color-extractor.ts, src/extractors/typography-extractor.ts</files>
  <action>
Implement TOKEN-01 (colors) and TOKEN-02 (typography) extractors.

1. src/extractors/color-extractor.ts -- TOKEN-01:

Export async function extractColors(page: Page, pageUrl: string): Promise<ColorToken[]>

Implementation:
a. Call getAllVisibleElements(page) to get all elements with computed styles
b. For each element, extract color-related properties:
   - backgroundColor -> context: 'background'
   - color -> context: 'text'
   - borderColor (borderTopColor) -> context: 'border'
   - For buttons/links/[role="button"] -> context: 'accent'
c. Filter out transparent backgrounds (rgba(0,0,0,0))
d. Convert each color to hex using parseColorToHex
e. Build ColorToken for each valid color:
   - value: hex string
   - originalValue: the raw CSS value
   - category: 'unknown' for now (semantic grouping done in Phase 2 normalization)
   - context: determined by which property it came from
   - evidence: [{ pageUrl, selector, timestamp, computedStyles: {the relevant property: value} }]
f. Deduplicate within page: if same hex appears on multiple elements, merge their evidence arrays
g. Return array of ColorToken

Note on semantic grouping (category field): For v1, set category to 'unknown'. True semantic grouping (primary/secondary/accent/neutral) requires cross-page frequency analysis which happens in Phase 2. The extraction here captures raw observations.

2. src/extractors/typography-extractor.ts -- TOKEN-02:

Export async function extractTypography(page: Page, pageUrl: string): Promise<TypographyToken[]>

Implementation:
a. Call getAllVisibleElements(page) -- reuse same data if possible, or call again
b. For each element that has text content (filter: elements with innerText.trim().length > 0):
   - Extract: fontFamily, fontSize, fontWeight, lineHeight, letterSpacing
c. Parse fontSize to pixels using parseSizeToPixels
d. Parse fontWeight to number (handle 'normal' = 400, 'bold' = 700)
e. Build TypographyToken:
   - family: fontFamily (strip quotes)
   - size: raw fontSize string
   - sizePixels: parsed px value
   - weight: numeric weight
   - lineHeight: raw value
   - letterSpacing: raw value
   - evidence: [{ pageUrl, selector, timestamp, computedStyles: all typography props }]
f. Deduplicate: merge tokens with same family+sizePixels+weight (within page)
g. Return array of TypographyToken

For both extractors:
- Use createLogger('color-extractor') / createLogger('typography-extractor')
- Wrap all page.evaluate calls in try/catch
- Log count of tokens extracted at info level
  </action>
  <verify>Run `npx tsc --noEmit` -- should compile with zero errors.</verify>
  <done>Color extractor captures bg/text/border/accent colors as hex with evidence. Typography extractor captures font families, sizes (px-normalized), weights, line-heights with evidence. Both deduplicate within-page observations.</done>
</task>

<task type="auto">
  <name>Task 3: Implement spacing and CSS custom property extractors</name>
  <files>src/extractors/spacing-extractor.ts, src/extractors/custom-properties-extractor.ts</files>
  <action>
Implement TOKEN-03 (spacing) and TOKEN-04 (CSS custom properties) extractors.

1. src/extractors/spacing-extractor.ts -- TOKEN-03:

Export async function extractSpacing(page: Page, pageUrl: string): Promise<SpacingToken[]>

Implementation:
a. Call getAllVisibleElements(page)
b. For each element, extract spacing properties:
   - margin: marginTop, marginRight, marginBottom, marginLeft
   - padding: paddingTop, paddingRight, paddingBottom, paddingLeft
   - gap: gap, rowGap, columnGap
c. Parse each value to pixels using parseSizeToPixels
d. Filter out 0px values (not meaningful as tokens) and 'auto' margins
e. Build SpacingToken for each unique value:
   - value: raw CSS string
   - valuePixels: parsed px value
   - context: 'margin' | 'padding' | 'gap'
   - evidence: [{ pageUrl, selector, timestamp, computedStyles }]
f. Deduplicate: merge tokens with same valuePixels + context
g. Return array of SpacingToken

Also export function detectBaseUnit(tokens: SpacingToken[]): number | null:
   - Collect all unique pixel values
   - Try common base units: 4, 8, 6, 10
   - For each candidate, count how many token values are exact multiples
   - If 80%+ of values are multiples of a candidate, return that as base unit
   - If no candidate reaches 80%, return null (no clear base unit)
   - This is a heuristic -- Phase 2 will refine

2. src/extractors/custom-properties-extractor.ts -- TOKEN-04:

Export async function extractCustomProperties(page: Page, pageUrl: string): Promise<CustomPropertyToken[]>

Implementation:
a. Extract custom properties from :root via page.evaluate:
   ```
   const rootStyles = getComputedStyle(document.documentElement);
   // Get all custom properties from stylesheets
   const customProps: Record<string, string> = {};
   for (const sheet of document.styleSheets) {
     try {
       for (const rule of sheet.cssRules) {
         if (rule instanceof CSSStyleRule && rule.selectorText === ':root') {
           for (let i = 0; i < rule.style.length; i++) {
             const name = rule.style[i];
             if (name.startsWith('--')) {
               customProps[name] = rule.style.getPropertyValue(name).trim();
             }
           }
         }
       }
     } catch (e) { /* cross-origin stylesheet, skip */ }
   }
   // Also get resolved values
   for (const name of Object.keys(customProps)) {
     customProps[name + '__resolved'] = rootStyles.getPropertyValue(name).trim();
   }
   return customProps;
   ```
b. For each custom property, categorize by naming convention heuristics:
   - Name contains 'color', 'bg', 'text', 'border' -> category: 'color'
   - Name contains 'font', 'text-size', 'type' -> category: 'typography'
   - Name contains 'space', 'gap', 'margin', 'padding' -> category: 'spacing'
   - Name contains 'radius', 'round' -> category: 'radius'
   - Name contains 'shadow', 'elevation' -> category: 'shadow'
   - Name contains 'duration', 'ease', 'transition', 'animation' -> category: 'motion'
   - Otherwise -> category: 'other'
c. Build CustomPropertyToken:
   - name: the custom property name (e.g., '--primary-color')
   - value: resolved value from getComputedStyle
   - rawValue: the declared value (may contain var() references)
   - category: heuristic categorization
   - evidence: [{ pageUrl, selector: ':root', timestamp, computedStyles: { [name]: resolvedValue } }]
d. Return array of CustomPropertyToken

Handle cross-origin stylesheet errors by wrapping in try/catch (research pitfall #6). Log count of custom properties found.
  </action>
  <verify>Run `npx tsc --noEmit` -- should compile with zero errors.</verify>
  <done>Spacing extractor captures margin/padding/gap values normalized to px with base unit detection heuristic. CSS custom property extractor reads :root variables, resolves values, and categorizes by naming convention. Both attach evidence.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. All four extractors export typed async functions accepting (Page, string) and returning token arrays
3. Shared style-utils provides element scanning, color parsing, size parsing
4. Token types match the definitions from Plan 01
5. Evidence is attached to every extracted token
</verification>

<success_criteria>
- TOKEN-01: extractColors returns ColorToken[] with hex values, context classification, and evidence
- TOKEN-02: extractTypography returns TypographyToken[] with px-normalized sizes, weights, and evidence
- TOKEN-03: extractSpacing returns SpacingToken[] with px-normalized values and base unit detection
- TOKEN-04: extractCustomProperties returns CustomPropertyToken[] with resolved values and category heuristics
- All extractors handle errors gracefully (try/catch, never crash the crawl)
- Within-page deduplication merges evidence for identical token values
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-crawling-infrastructure/01-04-SUMMARY.md`
</output>
