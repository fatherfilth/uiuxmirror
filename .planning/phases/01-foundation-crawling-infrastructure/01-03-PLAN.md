---
phase: 01-foundation-crawling-infrastructure
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/evidence/evidence-store.ts
  - src/evidence/screenshot-manager.ts
  - src/evidence/index.ts
autonomous: true

must_haves:
  truths:
    - "Every evidence entry stores pageUrl, selector, timestamp, screenshot path, and computed styles"
    - "Evidence entries have unique deterministic IDs based on content hash"
    - "Screenshot crops are saved atomically without file corruption"
    - "Evidence index can be queried by page URL or selector"
  artifacts:
    - path: "src/evidence/evidence-store.ts"
      provides: "File-based evidence index with CRUD operations"
      exports: ["EvidenceStore"]
    - path: "src/evidence/screenshot-manager.ts"
      provides: "Element screenshot capture and management"
      exports: ["ScreenshotManager"]
  key_links:
    - from: "src/evidence/evidence-store.ts"
      to: "src/types/evidence.ts"
      via: "stores EvidenceEntry objects in EvidenceIndex"
      pattern: "EvidenceEntry|EvidenceIndex"
    - from: "src/evidence/evidence-store.ts"
      to: "src/shared/utils.ts"
      via: "uses generateEvidenceId for deterministic IDs"
      pattern: "generateEvidenceId"
    - from: "src/evidence/screenshot-manager.ts"
      to: "src/evidence/evidence-store.ts"
      via: "screenshot paths stored in evidence entries"
      pattern: "screenshotPath"
---

<objective>
Build the evidence storage layer that links every extracted observation to its source with full traceability.

Purpose: Evidence tracing is the project's core differentiator. Every token extracted in Plans 04/05 must have provenance -- the page URL, DOM selector, timestamp, screenshot crop, and computed styles that prove the observation is real. This plan builds the storage infrastructure for that evidence.

Output: An EvidenceStore class for persisting evidence entries to JSON files, and a ScreenshotManager for capturing and storing element screenshot crops.
</objective>

<execution_context>
@C:/Users/Karl/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Karl/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@C:/Users/Karl/UIUX-Mirror/.planning/PROJECT.md
@C:/Users/Karl/UIUX-Mirror/.planning/phases/01-foundation-crawling-infrastructure/01-RESEARCH.md
@C:/Users/Karl/UIUX-Mirror/.planning/phases/01-foundation-crawling-infrastructure/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement ScreenshotManager for element evidence capture</name>
  <files>src/evidence/screenshot-manager.ts</files>
  <action>
Create the ScreenshotManager class that captures element-level screenshot crops for evidence.

src/evidence/screenshot-manager.ts:

1. ScreenshotManager class with constructor(outputDir: string):
   - outputDir is the base directory for screenshots (e.g., '.uidna/evidence/screenshots')
   - Constructor calls fs-extra ensureDirSync on outputDir

2. async captureElement(page: Page, selector: string, pageUrl: string): Promise<{ screenshotPath: string; boundingBox: BoundingBox | null }>
   - Generate unique filename: `{urlHash}-{selectorHash}-{timestamp}.png`
     where urlHash = first 8 chars of SHA-256(pageUrl), selectorHash = first 8 chars of SHA-256(selector), timestamp = Date.now()
   - This avoids filename collisions even with concurrent crawling (research pitfall #4)
   - Try to locate element via page.locator(selector)
   - If element is visible (waitFor state: 'visible' with 2s timeout):
     a. Capture screenshot: element.screenshot({ path: fullPath })
     b. Get boundingBox: element.boundingBox()
     c. Return { screenshotPath: relative path from outputDir root, boundingBox }
   - If element not visible or error: log warning, return { screenshotPath: undefined, boundingBox: null }
   - Wrap in try/catch -- screenshot failures must never crash the crawl

3. async captureFullPage(page: Page, pageUrl: string): Promise<string | undefined>
   - Generate filename: `page-{urlHash}-{timestamp}.png`
   - Capture full page: page.screenshot({ path, fullPage: true })
   - Return relative screenshot path, or undefined on error

4. Use fs-extra writeFile for atomic writes (prevents corruption from concurrent access).
   Use createLogger('screenshot-manager') for logging.

Import Page type from 'playwright' (not playwright-extra). The page object passed to these methods comes from Crawlee's request handler.
  </action>
  <verify>
Run `npx tsc --noEmit` -- should compile with zero errors.
  </verify>
  <done>ScreenshotManager captures element screenshots with unique filenames (no collisions), handles missing/invisible elements gracefully, and uses atomic file writes</done>
</task>

<task type="auto">
  <name>Task 2: Implement EvidenceStore for file-based evidence persistence</name>
  <files>src/evidence/evidence-store.ts, src/evidence/index.ts</files>
  <action>
Create the EvidenceStore class that persists evidence entries to disk with queryable indexes.

1. src/evidence/evidence-store.ts:

EvidenceStore class with constructor(outputDir: string):
   - outputDir is base evidence directory (e.g., '.uidna/evidence')
   - Constructor ensures output directory exists
   - Maintains in-memory EvidenceIndex that syncs to disk

Methods:

a. async addEvidence(params: { pageUrl: string; selector: string; computedStyles: Record<string, string>; screenshotPath?: string; boundingBox?: BoundingBox }): Promise<EvidenceEntry>
   - Generate timestamp: new Date().toISOString()
   - Generate ID using generateEvidenceId(pageUrl, selector, timestamp) from shared/utils
   - Create EvidenceEntry object
   - Add to in-memory index: entries[id] = entry
   - Update byPage index: push id to byPage[pageUrl] array
   - Update bySelector index: push id to bySelector[selector] array
   - Return the entry

b. async flush(): Promise<void>
   - Write full EvidenceIndex to disk: {outputDir}/evidence-index.json
   - Use fs-extra writeJson with { spaces: 2 } for readability
   - Use atomic write pattern: write to temp file then rename
   - Log count of entries flushed

c. async load(): Promise<void>
   - Read {outputDir}/evidence-index.json if exists
   - Populate in-memory index from file
   - If file doesn't exist, start with empty index

d. getByPage(pageUrl: string): EvidenceEntry[]
   - Look up IDs from byPage index, return full entries

e. getBySelector(selector: string): EvidenceEntry[]
   - Look up IDs from bySelector index, return full entries

f. getById(id: string): EvidenceEntry | undefined
   - Direct lookup in entries map

g. getAll(): EvidenceEntry[]
   - Return all entries as array

h. get count(): number
   - Return Object.keys(this.index.entries).length

Flush strategy: Callers should call flush() periodically (e.g., after each page is processed) and at the end of a crawl. Don't flush after every addEvidence -- too much I/O.

2. src/evidence/index.ts -- Barrel export:
   - Export { EvidenceStore } from './evidence-store.js'
   - Export { ScreenshotManager } from './screenshot-manager.js'

Use createLogger('evidence-store') for all logging.
  </action>
  <verify>
Run `npx tsc --noEmit` -- should compile with zero errors.
Run: `npx tsx -e "
import { EvidenceStore } from './src/evidence/index.js';
const store = new EvidenceStore('.uidna/test-evidence');
const entry = await store.addEvidence({ pageUrl: 'https://example.com', selector: 'h1', computedStyles: { color: 'rgb(0,0,0)' } });
console.log('Entry ID:', entry.id);
console.log('Count:', store.count);
await store.flush();
console.log('Flushed OK');
const byPage = store.getByPage('https://example.com');
console.log('By page:', byPage.length);
"` -- should create evidence entry, flush to disk, and query by page.
Clean up: `rm -rf .uidna/test-evidence`
  </verify>
  <done>EvidenceStore persists evidence to JSON with byPage and bySelector indexes. Entries have deterministic IDs. Flush writes atomically. All NORM-03 fields captured (pageUrl, selector, timestamp, screenshot, computedStyles).</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. EvidenceStore creates entries with all NORM-03 fields (pageUrl, selector, timestamp, screenshotPath, computedStyles)
3. Evidence IDs are deterministic (same inputs = same ID)
4. flush() writes valid JSON to disk
5. load() restores state from disk
6. getByPage() and getBySelector() return correct entries
7. ScreenshotManager generates unique filenames (no collisions)
</verification>

<success_criteria>
- NORM-03: Evidence entries store pageUrl, DOM selector, screenshot crop path, computed styles, and timestamp
- Evidence IDs are deterministic hashes (reproducible)
- File writes are atomic (no corruption from concurrent access)
- Evidence index is queryable by page URL and selector
- Screenshot capture handles missing/invisible elements without crashing
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-crawling-infrastructure/01-03-SUMMARY.md`
</output>
