# Phase 5: Export & Reporting - Research

**Researched:** 2026-02-16
**Domain:** Design token export, documentation generation, component stub templating
**Confidence:** HIGH

## Summary

Phase 5 transforms extracted design DNA into consumable artifacts: machine-readable exports (CSS, Tailwind, Figma), human-readable documentation (Markdown Brand DNA Report), and developer-ready component stubs (vanilla HTML/CSS). The project already uses TypeScript, Handlebars for templating, and fs-extra for file operations. The phase must generate three export formats (CSS custom properties, Tailwind config, Figma tokens), dual-layer JSON exports (quick-lookup + rich context), single-file HTML component stubs with embedded styles, and comprehensive Markdown documentation with inline evidence citations.

**Primary recommendation:** Use the existing Handlebars template infrastructure for component stubs, write simple TypeScript formatters for the three export formats (avoid Style Dictionary overhead), use markdown-table for programmatic table generation in reports, and organize exports in a clear directory structure (.uidna/exports/). Do not hand-roll token name generation—use semantic naming algorithms based on token characteristics.

<user_constraints>
## User Constraints (from CONTEXT.md)

### Locked Decisions

**Export format priorities:**
- CSS custom properties is the primary format (lowest friction, works everywhere)
- All formats generated by default — no config needed to select formats
- Three export formats: CSS custom properties, Tailwind config, Figma tokens plugin format
- No additional formats beyond the three (SCSS, Style Dictionary, etc. not needed)
- Machine-readable JSON exports structured in two layers:
  - **Quick-lookup layer**: Direct token name → CSS value mappings for programmatic application
  - **Rich context layer**: Descriptions, evidence, relationships, and reasoning context for AI agents
- Agent-consumable export format is a priority — Claude agents are a primary consumer alongside developers

**Component stub format:**
- Stubs are **copy-paste starters** — working HTML/CSS you can drop into a project and build on
- Single-file format: one `.html` file per component with embedded `<style>` block (self-contained)
- All detected states included in one file (hover, focus, disabled, etc.) via CSS pseudo-classes and variant markup
- Stubs reference CSS custom properties (`var(--color-primary)`) — requires the CSS vars export alongside
- Stubs are not baked-in values; they connect to the token system

**Report structure & depth:**
- Primary audience: **Claude agents and developers** — structure for both AI and human consumption
- Token presentation: tables with values **plus usage examples** (code snippets showing application)
- Component catalog is **inline** within the main Brand DNA Report (not a separate document)
- Evidence citations are **inline** — each token/component shows source pages where it was observed
- Content style guide (voice/tone, CTA rules, error grammar) is a **separate document** (`content-style-guide.md`), not a section in the main report
- Report is Markdown format

### Claude's Discretion

- Report section ordering and heading structure
- Table formatting and column choices
- How to present interaction flow documentation
- Level of detail in usage examples
- Evidence citation formatting (parenthetical vs footnote-style)

### Deferred Ideas (OUT OF SCOPE)

- MCP server/tool for Claude agents to query and apply design DNA — Phase 6
- CLI commands for export invocation (`uidna export`) — Phase 6

</user_constraints>

## Standard Stack

### Core

| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| TypeScript | ^5.7.2 | Type safety and compilation | Already project dependency, type-safe export generation |
| Handlebars | ^4.7.8 | Template engine for component stubs | Already used in `synthesis/template-registry.ts`, proven pattern for HTML generation |
| fs-extra | ^11.2.0 | File system operations | Already project dependency, provides `ensureDir` and `outputFile` for safe writes |
| markdown-table | Latest | Programmatic markdown table generation | Standard library for GitHub-flavored markdown tables, TypeScript-typed |

### Supporting

| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| w3c-design-tokens-standard-schema | ^0.0.7 | W3C DTCG format validation | Already project dependency, validate Figma tokens export |
| culori | ^4.0.2 | Color manipulation for CSS output | Already project dependency, needed for color format conversion |

### Alternatives Considered

| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| Simple TypeScript formatters | Style Dictionary | Style Dictionary is powerful but adds complexity and configuration overhead. User explicitly doesn't want additional formats beyond the three specified. Custom formatters are simpler and meet exact requirements. |
| Handlebars | Template literals | Handlebars already integrated with custom helpers, supports partial reuse, and separates template logic from code. Template literals work but lack helper ecosystem. |
| markdown-table | Manual string concatenation | Manual table building is error-prone and hard to align. markdown-table handles alignment, escaping, and GFM compliance automatically. |

**Installation:**

```bash
npm install markdown-table
```

## Architecture Patterns

### Recommended Project Structure

```
src/
├── export/                    # NEW: Phase 5 export module
│   ├── index.ts              # Public API
│   ├── formatters/           # Format-specific exporters
│   │   ├── css-vars.ts       # CSS custom properties
│   │   ├── tailwind.ts       # Tailwind config
│   │   ├── figma-tokens.ts   # Figma tokens plugin format
│   │   └── json-layers.ts    # Dual-layer JSON (quick + rich)
│   ├── reports/              # Report generation
│   │   ├── brand-dna-report.ts      # Main markdown report
│   │   ├── content-style-guide.ts   # Separate content guide
│   │   └── markdown-utils.ts        # Table, code block helpers
│   ├── stubs/                # Component stub generation
│   │   ├── stub-generator.ts        # Orchestrator
│   │   └── stub-templates.ts        # Handlebars compilation
│   └── evidence-linker.ts    # Evidence citation formatting
└── synthesis/templates/      # EXISTING: Handlebars templates
    ├── button.hbs
    ├── card.hbs
    ├── input.hbs
    └── ...
```

### Pattern 1: Format-Specific Exporters

**What:** Each export format has a dedicated module that transforms normalized tokens into that format.

**When to use:** For CSS vars, Tailwind config, and Figma tokens—each requires different structure and conventions.

**Example:**

```typescript
// src/export/formatters/css-vars.ts
import type { NormalizationResult } from '../../types/normalized-tokens.js';

export function generateCSSCustomProperties(result: NormalizationResult): string {
  const lines: string[] = [':root {'];

  // Colors
  result.colors.standards.forEach((cluster, index) => {
    const name = generateColorName(cluster, index);
    lines.push(`  --${name}: ${cluster.token.canonical};`);
  });

  // Typography
  result.typography.standards.forEach((typo, index) => {
    const name = generateTypographyName(typo, index);
    const token = typo.token;
    lines.push(`  --${name}-family: ${token.family};`);
    lines.push(`  --${name}-size: ${token.size};`);
    lines.push(`  --${name}-weight: ${token.weight};`);
  });

  lines.push('}');
  return lines.join('\n');
}
```

**Why this pattern:** CSS custom properties use kebab-case naming and flat structure. Tailwind uses nested JS objects. Figma tokens use W3C DTCG format with `$type` and `$value`. Each is distinct enough to warrant dedicated modules.

### Pattern 2: Dual-Layer JSON Export

**What:** JSON exports have two consumption modes: quick-lookup (simple name→value map) and rich context (full metadata for AI agents).

**When to use:** For `tokens.json`, `components.json`, etc.—whenever machine consumers need both fast access and deep reasoning context.

**Example:**

```typescript
// src/export/formatters/json-layers.ts
export interface DualLayerJSON {
  quick: Record<string, string>;      // Fast lookup: "color-primary" → "#3b82f6"
  rich: Record<string, RichToken>;    // Full context with evidence, reasoning
}

export interface RichToken {
  value: string;
  type: string;
  description: string;
  evidence: Array<{
    pageUrl: string;
    selector: string;
    screenshotPath?: string;
  }>;
  confidence: {
    value: number;
    level: 'high' | 'medium' | 'low';
    reasoning: string;
  };
  relationships?: {
    similarTo?: string[];
    usedIn?: string[];  // Component names
  };
}

export function generateDualLayerJSON(result: NormalizationResult): DualLayerJSON {
  const quick: Record<string, string> = {};
  const rich: Record<string, RichToken> = {};

  result.colors.standards.forEach((cluster, index) => {
    const name = generateColorName(cluster, index);
    quick[name] = cluster.token.canonical;
    rich[name] = {
      value: cluster.token.canonical,
      type: 'color',
      description: `Appears on ${cluster.token.evidence.length} elements across ${cluster.pageUrls.size} pages`,
      evidence: cluster.token.evidence.map(e => ({
        pageUrl: e.pageUrl,
        selector: e.selector,
        screenshotPath: e.screenshotPath,
      })),
      confidence: {
        value: cluster.confidence,
        level: cluster.confidence > 0.6 ? 'high' : cluster.confidence > 0.3 ? 'medium' : 'low',
        reasoning: `${cluster.occurrenceCount} occurrences across ${cluster.pageUrls.size} pages`,
      },
    };
  });

  return { quick, rich };
}
```

**Why this pattern:** Developers grab quick values programmatically (`tokens.quick['color-primary']`). AI agents read rich context to reason about design decisions (`tokens.rich['color-primary'].evidence`).

### Pattern 3: Single-File Component Stubs

**What:** Component stubs are self-contained `.html` files with embedded `<style>` blocks, using CSS custom properties via `var()`.

**When to use:** For all detected and synthesized components—button, card, input, modal, nav, etc.

**Example:**

```typescript
// src/export/stubs/stub-generator.ts
import { compileTemplate } from '../../synthesis/template-registry.js';
import type { ComponentInstance } from '../../types/components.js';

export function generateComponentStub(
  component: ComponentInstance,
  cssVarNames: Record<string, string>  // Token name → CSS var name mapping
): string {
  const template = compileTemplate(component.type);

  return template({
    // Component-specific data
    label: 'Example Button',
    size: 'medium',
    emphasis: 'primary',

    // Token mappings (converts "color-primary" → "var(--color-primary)")
    tokens: transformTokensToVars(cssVarNames),
  });
}

function transformTokensToVars(cssVarNames: Record<string, string>): any {
  // Transform flat token names into nested structure for Handlebars
  // "color-primary" → { color: { primary: "var(--color-primary)" } }
  const result: any = {};

  for (const [tokenName, varName] of Object.entries(cssVarNames)) {
    const value = `var(${varName})`;
    // Parse tokenName and nest appropriately
    // Implementation depends on naming convention
    setNestedValue(result, tokenName, value);
  }

  return result;
}
```

**Why this pattern:** Single-file stubs are copy-paste ready. Developers can drop them into any HTML file and they work immediately. CSS custom properties connect stubs to the design system—change a token value, all stubs update.

### Pattern 4: Markdown Report with Inline Evidence

**What:** Generate GitHub-flavored markdown with tables, code examples, and inline evidence citations.

**When to use:** For the Brand DNA Report and Content Style Guide.

**Example:**

```typescript
// src/export/reports/brand-dna-report.ts
import { markdownTable } from 'markdown-table';
import type { NormalizationResult } from '../../types/normalized-tokens.js';

export function generateBrandDNAReport(
  result: NormalizationResult,
  components: ComponentInstance[]
): string {
  const sections: string[] = [
    '# Brand DNA Report',
    '',
    `Generated: ${new Date().toISOString()}`,
    '',
    '## Design Tokens',
    '',
    generateColorTokensSection(result.colors),
    '',
    generateTypographyTokensSection(result.typography),
    '',
    '## Component Catalog',
    '',
    generateComponentCatalog(components),
  ];

  return sections.join('\n');
}

function generateColorTokensSection(colors: any): string {
  const tableData = [
    ['Token Name', 'Value', 'Usage', 'Evidence'],
    ...colors.standards.map((cluster, index) => {
      const name = generateColorName(cluster, index);
      const evidence = formatEvidenceCitation(cluster.token.evidence);
      return [
        `\`${name}\``,
        cluster.token.canonical,
        `${cluster.occurrenceCount} occurrences across ${cluster.pageUrls.size} pages`,
        evidence,
      ];
    }),
  ];

  return [
    '### Colors',
    '',
    markdownTable(tableData),
    '',
    '**Usage Example:**',
    '```css',
    '.primary-button {',
    '  background-color: var(--color-primary);',
    '}',
    '```',
  ].join('\n');
}

function formatEvidenceCitation(evidence: TokenEvidence[]): string {
  // User discretion: parenthetical vs footnote
  // Using parenthetical for simplicity
  const firstThree = evidence.slice(0, 3);
  const urls = firstThree.map(e => new URL(e.pageUrl).pathname).join(', ');
  const more = evidence.length > 3 ? ` (+${evidence.length - 3} more)` : '';
  return `\`${urls}${more}\``;
}
```

**Why this pattern:** markdown-table handles alignment and escaping. Inline evidence shows developers exactly where tokens were observed. Code examples demonstrate practical usage.

### Anti-Patterns to Avoid

- **Hard-coded token names:** Generate semantic names algorithmically based on characteristics (color hue, typography size, spacing scale position). Don't manually assign "primary", "secondary", etc.
- **Baked-in values in stubs:** Component stubs must use CSS custom properties, not hard-coded hex colors or pixel values. Stubs should connect to the token system.
- **Monolithic export function:** Don't create one giant function that generates all formats. Each format has unique concerns—separate modules improve testability and maintainability.
- **Case-sensitive token names:** Avoid token names that differ only by case (e.g., `Font-Size` vs `font-size`). Some platforms don't support case-sensitive names, causing export collisions.

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Markdown table alignment | Manual space padding | `markdown-table` library | Tables need proper column alignment, escaping, and GFM compliance. Manual padding breaks with unicode characters and is error-prone. |
| Token name generation | Random or incremental IDs | Semantic naming algorithm | Token names should reflect purpose ("color-primary", not "color-1"). Algorithm can analyze hue, frequency, context to generate meaningful names. |
| CSS var naming conventions | Custom kebab-case logic | kebab-case library or simple `.toLowerCase().replace(/\s+/g, '-')` | CSS custom properties require kebab-case. Don't write regex for this—use proven patterns. |
| File path safety | Manual path.join and mkdir | `fs-extra.ensureDir` and `outputFile` | Creating nested directories safely is tricky (race conditions, permissions). fs-extra handles this correctly. |
| Figma tokens validation | Custom JSON schema | `w3c-design-tokens-standard-schema` validator | W3C DTCG spec is complex. Use official validator to ensure compliance. Already a project dependency. |

**Key insight:** Export systems have many edge cases—file writes failing, token name collisions, markdown escaping, format validation. Use libraries that handle these edge cases so you can focus on business logic.

## Common Pitfalls

### Pitfall 1: One-Time Export Without Iteration

**What goes wrong:** Generate exports once, never update them as source data changes. Reports become stale, formats drift.

**Why it happens:** Export generation is treated as a one-time script instead of a repeatable pipeline.

**How to avoid:** Design export functions as pure transformations: `(NormalizationResult) => string`. Make them testable and idempotent. Store exports in `.uidna/exports/` with timestamps, allow re-generation on demand.

**Warning signs:** Hard-coded output paths, side effects in formatters, no version metadata in exports.

### Pitfall 2: Poor Token Naming Conventions

**What goes wrong:** Generic names like "color-1", "color-2" make tokens unmaintainable. Developers can't remember which is which.

**Why it happens:** Incremental naming is easier than semantic analysis.

**How to avoid:** Analyze token characteristics to generate semantic names:
- **Colors:** Use hue analysis (primary → most saturated brand color, neutral → grays, accent → secondary hues)
- **Typography:** Use size relationships (heading-1 → largest, body → most common)
- **Spacing:** Use scale position (xs, sm, md, lg, xl based on ascending pixel values)

**Warning signs:** Token names with only numbers, no relationship between name and value, developers asking "what is color-3?"

### Pitfall 3: Token Names Differing Only by Case

**What goes wrong:** `Font-Size` and `font-size` create duplicate exports in case-insensitive environments (Windows, some build tools).

**Why it happens:** Mixing naming conventions (PascalCase from Figma, kebab-case for CSS).

**How to avoid:** Normalize all token names to lowercase kebab-case early in the export pipeline. Validate for case-only collisions before writing files.

**Warning signs:** Export errors on Windows, Tailwind config with overridden values, CSS vars not working.

### Pitfall 4: Evidence Links Breaking

**What goes wrong:** Evidence citations reference screenshot paths that don't exist, or URLs that change format.

**Why it happens:** Evidence is stored with absolute paths or includes localhost URLs from crawling.

**How to avoid:** Store evidence with relative paths from project root (`.uidna/screenshots/...`). Convert absolute crawl URLs to human-readable citations (show path, not full URL). Validate that screenshot files exist before generating citations.

**Warning signs:** Broken image links in reports, file:// URLs in markdown, screenshot paths with timestamps that no longer exist.

### Pitfall 5: Component-Tied Tokens

**What goes wrong:** Creating tokens like "button-background-color" limits reusability. Other components can't use these tokens without semantic confusion.

**Why it happens:** Extracting tokens from specific components and naming them after those components.

**How to avoid:** Generate semantic token names based on visual characteristics (color-primary) not component names (button-color). Tokens should be component-agnostic primitives.

**Warning signs:** Token names include component types, duplication across components (button-blue and card-blue are the same blue), inability to apply tokens outside original context.

### Pitfall 6: Large Single-File Reports

**What goes wrong:** Generating a 50MB markdown file with all tokens, components, evidence, and screenshots becomes unreadable and breaks markdown viewers.

**Why it happens:** Including full evidence for every token inline, embedding base64 screenshots, no pagination.

**How to avoid:** Limit inline evidence to first 3 examples, link to full evidence index. Use external screenshot files, not base64. Consider splitting very large reports (>5000 lines) into sections.

**Warning signs:** GitHub refusing to render markdown, VS Code markdown preview hanging, reports taking >5 seconds to generate.

## Code Examples

Verified patterns from research and existing codebase:

### CSS Custom Properties Generation

```typescript
// Source: Existing pattern from dtcg-formatter.ts + CSS vars research
import type { NormalizationResult } from '../types/normalized-tokens.js';

export function generateCSSCustomProperties(result: NormalizationResult): string {
  const lines: string[] = [
    '/**',
    ' * CSS Custom Properties - Design Tokens',
    ` * Generated: ${new Date().toISOString()}`,
    ' * Do not edit manually - regenerate from source',
    ' */',
    '',
    ':root {',
    '  /* Colors */',
  ];

  // Colors
  result.colors.standards.forEach((cluster, index) => {
    const name = generateSemanticColorName(cluster, index);
    lines.push(`  --${name}: ${cluster.token.canonical};`);
  });

  lines.push('');
  lines.push('  /* Typography */');

  // Typography
  result.typography.standards.forEach((typo, index) => {
    const name = generateSemanticTypographyName(typo, index);
    const token = typo.token;
    lines.push(`  --${name}-family: ${token.family};`);
    lines.push(`  --${name}-size: ${token.size};`);
    lines.push(`  --${name}-weight: ${token.weight};`);
    if (token.lineHeight) {
      lines.push(`  --${name}-line-height: ${token.lineHeight};`);
    }
  });

  lines.push('}');
  return lines.join('\n');
}
```

### Tailwind Config Generation

```typescript
// Source: Tailwind CSS v4 @theme research + Style Dictionary patterns
import type { NormalizationResult } from '../types/normalized-tokens.js';

export function generateTailwindConfig(result: NormalizationResult): string {
  // Generate Tailwind v3 config (JS object)
  // For v4, could generate @theme CSS instead

  const config = {
    theme: {
      extend: {
        colors: {},
        fontSize: {},
        spacing: {},
        borderRadius: {},
        boxShadow: {},
      },
    },
  };

  // Colors
  result.colors.standards.forEach((cluster, index) => {
    const name = generateSemanticColorName(cluster, index);
    config.theme.extend.colors[name] = cluster.token.canonical;
  });

  // Typography (font sizes)
  result.typography.standards.forEach((typo, index) => {
    const name = generateSemanticTypographyName(typo, index);
    config.theme.extend.fontSize[name] = [
      typo.token.size,
      { lineHeight: typo.token.lineHeight || '1.5' },
    ];
  });

  // Spacing
  result.spacing.standards.forEach((spacing, index) => {
    const name = generateSemanticSpacingName(spacing, index);
    config.theme.extend.spacing[name] = spacing.token.value;
  });

  return [
    '/** @type {import("tailwindcss").Config} */',
    'module.exports = ' + JSON.stringify(config, null, 2),
  ].join('\n');
}
```

### Figma Tokens Plugin Format

```typescript
// Source: W3C DTCG format specification + Figma tokens plugin research
import type { NormalizationResult } from '../types/normalized-tokens.js';

export function generateFigmaTokens(result: NormalizationResult): string {
  // Figma tokens use W3C DTCG format with $type, $value
  const figmaTokens: Record<string, any> = {};

  // Color group
  const colors: Record<string, any> = {};
  result.colors.standards.forEach((cluster, index) => {
    const name = generateSemanticColorName(cluster, index);
    colors[name] = {
      $type: 'color',
      $value: cluster.token.canonical,
      $description: `Appears on ${cluster.occurrenceCount} elements across ${cluster.pageUrls.size} pages`,
    };
  });
  figmaTokens.colors = colors;

  // Typography group
  const typography: Record<string, any> = {};
  result.typography.standards.forEach((typo, index) => {
    const name = generateSemanticTypographyName(typo, index);
    typography[name] = {
      $type: 'typography',
      $value: {
        fontFamily: typo.token.family,
        fontSize: typo.token.size,
        fontWeight: typo.token.weight,
        lineHeight: typo.token.lineHeight || '1.5',
      },
    };
  });
  figmaTokens.typography = typography;

  return JSON.stringify(figmaTokens, null, 2);
}
```

### Markdown Table Generation

```typescript
// Source: markdown-table library documentation
import { markdownTable } from 'markdown-table';
import type { ColorCluster } from '../types/normalized-tokens.js';

export function generateColorTokenTable(clusters: any[]): string {
  const tableData = [
    ['Token Name', 'Value', 'Occurrences', 'Pages', 'Evidence'],
    ...clusters.map((cluster, index) => {
      const name = generateSemanticColorName(cluster, index);
      const evidence = formatEvidenceCitation(cluster.token.evidence);
      return [
        `\`${name}\``,
        cluster.token.canonical,
        String(cluster.occurrenceCount),
        String(cluster.pageUrls.size),
        evidence,
      ];
    }),
  ];

  return markdownTable(tableData, {
    align: ['l', 'l', 'r', 'r', 'l'],  // Left, left, right, right, left
  });
}

function formatEvidenceCitation(evidence: TokenEvidence[]): string {
  const firstThree = evidence.slice(0, 3);
  const paths = firstThree.map(e => {
    const url = new URL(e.pageUrl);
    return url.pathname === '/' ? url.hostname : url.pathname;
  });
  const more = evidence.length > 3 ? ` (+${evidence.length - 3} more)` : '';
  return paths.join(', ') + more;
}
```

### Component Stub with Handlebars

```typescript
// Source: Existing template-registry.ts + Handlebars research
import { compileTemplate } from '../synthesis/template-registry.js';
import type { ComponentInstance } from '../types/components.js';

export function generateComponentStub(
  component: ComponentInstance,
  tokenVarMap: Record<string, string>  // "color-primary" → "--color-primary"
): string {
  const template = compileTemplate(component.type);

  // Transform token map into nested structure for Handlebars
  const tokens = buildTokensObject(tokenVarMap);

  return template({
    // Component variant data
    size: component.variants?.size || 'medium',
    emphasis: component.variants?.emphasis || 'primary',
    label: `Example ${component.type}`,

    // Token references
    tokens,
  });
}

function buildTokensObject(tokenVarMap: Record<string, string>): any {
  const result: any = {
    color: {},
    typography: {},
    spacing: {},
    radius: {},
    shadow: {},
  };

  for (const [tokenName, varName] of Object.entries(tokenVarMap)) {
    const value = `var(${varName})`;

    // Parse token name: "color-primary" → result.color.primary = "var(--color-primary)"
    const [category, ...rest] = tokenName.split('-');
    const key = rest.join('-') || 'default';

    if (result[category]) {
      result[category][key] = value;
    }
  }

  return result;
}
```

### Safe File Writing

```typescript
// Source: fs-extra documentation + TypeScript patterns
import { outputFile, ensureDir } from 'fs-extra';
import { join } from 'path';

export async function writeExportFile(
  filename: string,
  content: string,
  exportType: 'formats' | 'reports' | 'stubs'
): Promise<void> {
  const exportDir = join(process.cwd(), '.uidna', 'exports', exportType);
  await ensureDir(exportDir);

  const filePath = join(exportDir, filename);
  await outputFile(filePath, content, 'utf-8');
}

// Usage:
await writeExportFile('tokens.css', cssContent, 'formats');
await writeExportFile('brand-dna-report.md', reportContent, 'reports');
await writeExportFile('button.html', stubContent, 'stubs');
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Style Dictionary for all formats | Custom formatters per format | 2024-2025 | Simpler, no config files needed, direct control over output. Style Dictionary best for large multi-platform systems; overkill for 3 formats. |
| Monolithic export scripts | Modular format-specific exporters | 2025 | Better testability, easier to maintain and extend individual formats. |
| Manual markdown generation | Programmatic table libraries | 2023-2024 | Eliminates alignment bugs, proper escaping, GFM compliance guaranteed. |
| Base64 screenshot embedding | External file references | 2024 | Smaller reports, faster loading, better for version control. |
| Tailwind v3 JS config | Tailwind v4 @theme CSS | 2024-2025 | CSS-first configuration, faster builds, CSS variables by default. **Note:** Can generate either format depending on user's Tailwind version. |
| Template literals for HTML | Handlebars with helpers | 2020s | Better separation of concerns, reusable templates, cleaner code. |

**Deprecated/outdated:**

- **SCSS/LESS token exports:** Modern build tools use CSS custom properties or Tailwind. SCSS/LESS preprocessing less common in 2026.
- **Style Dictionary for simple use cases:** Excellent for complex multi-platform systems, but adds unnecessary configuration overhead for three well-defined formats.
- **Inline Base64 screenshots in markdown:** Bloats file size, breaks GitHub rendering, hard to diff in version control. Use file references.

## Open Questions

1. **Token naming algorithm specifics**
   - What we know: Need semantic names based on characteristics (hue, frequency, size)
   - What's unclear: Exact heuristics for "primary" vs "secondary" vs "accent" color classification
   - Recommendation: Use simple heuristics (most frequent = primary, most saturated = accent), allow manual override in future phases. Document algorithm in code comments.

2. **Evidence citation depth in reports**
   - What we know: Inline citations should show source pages, not overwhelm the reader
   - What's unclear: User discretion on format—parenthetical or footnote-style
   - Recommendation: Start with parenthetical (simpler, inline). Show first 3 evidence sources, "+N more" suffix. Full evidence available in `evidence_index.json`.

3. **Tailwind v3 vs v4 config format**
   - What we know: v4 uses @theme CSS directive, v3 uses JS config
   - What's unclear: Which version to target (user may have either)
   - Recommendation: Generate v3 JS config (broader compatibility). Comment in code that v4 @theme could be alternative format. User can request v4 format if needed.

4. **Component stub state coverage**
   - What we know: Stubs should include all detected states (hover, focus, disabled)
   - What's unclear: How to represent states not observed but semantically expected (e.g., :focus-visible)
   - Recommendation: Include standard accessibility states even if not observed (:hover, :focus, :active, :disabled). Mark synthesized states in code comments.

## Sources

### Primary (HIGH confidence)

- **Existing codebase:**
  - `src/output/dtcg-formatter.ts` - W3C DTCG format patterns
  - `src/synthesis/template-registry.ts` - Handlebars compilation and helper patterns
  - `src/types/evidence.ts`, `src/types/normalized-tokens.ts`, `src/types/components.ts` - Data structures
  - `src/synthesis/templates/button.hbs`, `card.hbs` - Component template examples
- **Official documentation:**
  - [W3C Design Tokens Format Module 2025.10](https://www.designtokens.org/tr/drafts/format/) - DTCG specification
  - [Tokens Studio for Figma - JSON View](https://docs.tokens.studio/manage-tokens/token-sets/json-view) - Figma tokens format
  - [Handlebars Guide](https://handlebarsjs.com/guide/) - Template engine official docs
  - [markdown-table npm](https://www.npmjs.com/package/markdown-table) - Table generation library
  - [fs-extra npm](https://www.npmjs.com/package/fs-extra) - File system utilities
  - [Tailwind CSS v4 Documentation](https://tailwindcss.com/blog/tailwindcss-v4) - New @theme syntax

### Secondary (MEDIUM confidence)

- [Figma Tokens: Design Tokens Plugin](https://jansix.at/resources/figma-tokens) - Plugin format patterns
- [CSS Custom Properties Guide for 2026](https://devtoolbox.dedyn.io/blog/css-variables-complete-guide) - CSS vars best practices
- [Tailwind CSS 4 @theme Guide](https://medium.com/@sureshdotariya/tailwind-css-4-theme-the-future-of-design-tokens-at-2025-guide-48305a26af06) - v4 migration patterns
- [Style Dictionary Configuration](https://styledictionary.com/reference/config/) - Alternative approach (not using, but understand tradeoffs)
- [Building a Markdown-Based Documentation System](https://medium.com/@rosgluk/building-a-markdown-based-documentation-system-72bef3cb1db3) - Documentation structure patterns
- [Design System Doc Components](https://medium.com/eightshapes-llc/design-system-doc-components-8c0027322f8) - Report structure best practices
- [Common Mistakes in Design Tokens Adoption](https://designtokens.substack.com/p/common-mistakes-in-design-tokens) - Pitfall analysis
- [Requirements Traceability Links](https://www.reqview.com/doc/requirements-traceability-links/) - Evidence linking patterns
- [Screenshots as Evidence](https://visualping.io/blog/screenshots-as-evidence) - Screenshot documentation best practices

### Tertiary (LOW confidence)

- Web search results on general token export patterns - Used for context, verified against official docs where possible

## Metadata

**Confidence breakdown:**

- **Standard stack:** HIGH - All libraries already in project dependencies or well-established standards (markdown-table)
- **Architecture patterns:** HIGH - Based on existing codebase patterns (Handlebars templates, dtcg-formatter structure) plus verified library documentation
- **Export formats:** HIGH - CSS vars, Tailwind, and Figma tokens have official specifications and clear examples
- **Pitfalls:** MEDIUM-HIGH - Based on real-world design token adoption articles and official guidance, but some are general patterns not specific to this implementation

**Research date:** 2026-02-16
**Valid until:** 60 days (token export standards are relatively stable, CSS and Tailwind not fast-moving)

**Key unknowns requiring implementation decisions:**
- Exact token naming heuristics (primary/secondary/accent classification)
- Evidence citation format preference (user discretion)
- Tailwind v3 vs v4 target (recommend v3 for compatibility)
- State synthesis rules for component stubs
