---
phase: 05-export-reporting
plan: 04
type: execute
wave: 3
depends_on: ["05-03"]
files_modified:
  - src/export/stubs/stub-generator.ts
  - src/export/stubs/index.ts
autonomous: true

must_haves:
  truths:
    - "Each component type generates a single self-contained .html file with embedded style block"
    - "Component stubs reference CSS custom properties via var() not hard-coded values"
    - "All detected states (hover, focus, disabled, etc.) included via CSS pseudo-classes and variant markup"
    - "Stubs are copy-paste ready starter code that works when paired with CSS vars export"
  artifacts:
    - path: "src/export/stubs/stub-generator.ts"
      provides: "Component stub generation from aggregated components"
      exports: ["generateComponentStub", "generateAllStubs"]
    - path: "src/export/stubs/index.ts"
      provides: "Stubs barrel export"
  key_links:
    - from: "src/export/stubs/stub-generator.ts"
      to: "src/export/formatters/css-vars.ts"
      via: "CSS var names used in var() references"
      pattern: "import.*generateTokenVarName"
    - from: "src/export/stubs/stub-generator.ts"
      to: "src/export/semantic-namer.ts"
      via: "Semantic names for token references"
      pattern: "import.*generateSemantic"
---

<objective>
Generate framework-agnostic component stubs as single-file HTML with embedded CSS custom property references.

Purpose: Per user decision, stubs are copy-paste starters — working HTML/CSS you can drop into a project and build on. Each component is one .html file with an embedded `<style>` block. All stubs reference `var(--token-name)` so they connect to the token system. They are NOT baked-in values.

Output: `src/export/stubs/stub-generator.ts` producing self-contained HTML/CSS component files.
</objective>

<execution_context>
@C:/Users/Karl/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Karl/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-export-reporting/05-RESEARCH.md
@.planning/phases/05-export-reporting/05-CONTEXT.md
@.planning/phases/05-export-reporting/05-01-SUMMARY.md
@.planning/phases/05-export-reporting/05-03-SUMMARY.md
@src/types/components.ts
@src/types/synthesis.ts
@src/components/component-aggregator.ts
@src/synthesis/template-registry.ts
@src/synthesis/templates/button.hbs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create component stub generator</name>
  <files>
    src/export/stubs/stub-generator.ts
  </files>
  <action>
Create `src/export/stubs/stub-generator.ts`:

**Core function:**
`generateComponentStub(component: AggregatedComponent, tokenNames: TokenNameMap): string`

Where `TokenNameMap` = `{ colors: Record<number, string>, typography: Record<number, string>, spacing: Record<number, string>, radii: Record<number, string>, shadows: Record<number, string> }` — maps from index to semantic name (built by the caller from semantic-namer).

**Implementation strategy:**
Do NOT use the existing Handlebars templates from synthesis (those are for AI synthesis pipeline). Instead, generate HTML/CSS directly from the component's canonical styles. This is cleaner because:
- Synthesis templates have complex context requirements
- Stubs need CSS var references, not resolved values
- Stubs need all states in one file

**For each component type (button, input, card, nav, modal):**

Generate a self-contained HTML file:

```html
<!-- Component: [type] -->
<!-- Generated by UIUX-Mirror -->
<!-- Requires: tokens.css (CSS custom properties) -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>[Type] Component</title>
  <link rel="stylesheet" href="tokens.css">
  <style>
    /* [Type] Component Styles */
    .[type] {
      background-color: var(--color-primary);
      font-family: var(--body-1-family);
      font-size: var(--body-1-size);
      padding: var(--spacing-sm) var(--spacing-md);
      border-radius: var(--radius-sm);
      /* ... mapped from canonical styles */
    }

    /* States */
    .[type]:hover { ... }
    .[type]:focus { outline: 2px solid var(--color-primary); outline-offset: 2px; }
    .[type]:active { ... }
    .[type]:disabled { opacity: 0.5; cursor: not-allowed; }

    /* Variants (if detected) */
    .[type]--secondary { ... }
    .[type]--small { ... }
    .[type]--large { ... }
  </style>
</head>
<body>
  <h1>[Type] Component</h1>

  <!-- Default -->
  <[element] class="[type]">Example [Type]</[element]>

  <!-- Variants -->
  <[element] class="[type] [type]--secondary">Secondary [Type]</[element]>

  <!-- States -->
  <[element] class="[type]" disabled>Disabled [Type]</[element]>
</body>
</html>
```

**Style mapping logic:**
- Map canonical CSS properties to CSS custom property references:
  - `backgroundColor` -> find closest color token -> `var(--color-primary)` (or secondary/accent)
  - `fontSize` -> find closest typography token -> `var(--heading-1-size)` or `var(--body-1-size)`
  - `fontFamily` -> match to typography token -> `var(--heading-1-family)`
  - `padding` -> find closest spacing token -> `var(--spacing-sm)`
  - `borderRadius` -> find closest radius token -> `var(--radius-sm)`
  - `boxShadow` -> find closest shadow token -> `var(--shadow-sm)`
- Use a `mapStyleToVar(property: string, value: string, tokenNames: TokenNameMap): string | null` helper that finds the nearest token match for a canonical style value. For colors, compare hex values. For sizes, compare pixel values (within 2px tolerance).
- If no token match, use the raw value as fallback (with a comment noting it's not tokenized).

**State inclusion:**
- Always include `:hover`, `:focus`, `:active`, `:disabled` pseudo-class styles.
- If component has `states` (from StateMapping), use the actual observed state styles mapped to CSS vars.
- If states are null, generate standard accessibility states: focus with outline, disabled with opacity 0.5.
- Include focus-visible for keyboard accessibility (per phase 3 a11y patterns).

**Variant inclusion:**
- If component has variants with different emphasis values, generate BEM-style modifier classes: `.[type]--secondary`, `.[type]--tertiary`, `.[type]--ghost`.
- If component has size variants, generate `.[type]--small`, `.[type]--large`.

**HTML element selection by type:**
- button -> `<button>` element
- input -> `<input>` element with label
- card -> `<div>` with child structure (image placeholder, heading, body, action area)
- nav -> `<nav>` with `<ul><li><a>` structure
- modal -> `<dialog>` element with backdrop, header, body, footer

**Orchestrator function:**
`generateAllStubs(components: AggregatedComponent[], result: NormalizationResult): Map<string, string>`

Returns map of component type -> HTML string. For each component in the array:
1. Build TokenNameMap from NormalizationResult using semantic-namer functions
2. Call generateComponentStub for each component
3. Return Map<componentType, htmlString>
  </action>
  <verify>
    - `npx tsc --noEmit --skipLibCheck` passes (0 errors)
    - generateComponentStub and generateAllStubs compile with correct input types
  </verify>
  <done>
    - generateComponentStub produces self-contained HTML with embedded style block
    - All styles reference var(--token-name) not hard-coded values
    - States included via CSS pseudo-classes (hover, focus, active, disabled)
    - Variants included via BEM modifier classes
    - HTML uses semantic elements per component type (button, dialog, nav, etc.)
  </done>
</task>

<task type="auto">
  <name>Task 2: Create stubs barrel and update export index</name>
  <files>
    src/export/stubs/index.ts
    src/export/index.ts
  </files>
  <action>
1. Create `src/export/stubs/index.ts` barrel:
   - Re-export generateComponentStub, generateAllStubs from stub-generator.ts

2. Update `src/export/index.ts`:
   - Add re-export from `./stubs/index.js`
  </action>
  <verify>
    - `npx tsc --noEmit --skipLibCheck` passes (0 errors)
    - generateAllStubs accessible from src/export/index.ts
  </verify>
  <done>
    - Stubs module properly integrated into export barrel
    - All stub generation functions accessible from src/export/index.ts
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit --skipLibCheck` — Zero TypeScript errors
- Stub generator produces valid HTML5 documents
- All CSS in stubs uses var() references
- States (hover, focus, active, disabled) present in all component stubs
- Variant modifiers generated when component has multiple variants
</verification>

<success_criteria>
- Each component type produces a complete HTML5 document with embedded style
- Styles map canonical values to closest CSS custom property via var()
- All stubs include standard accessibility states (focus with outline, disabled with opacity)
- Card stub has child structure (image, heading, body, actions)
- Modal stub uses dialog element
- Nav stub uses nav/ul/li/a semantic structure
- Stubs are genuinely copy-paste ready (valid HTML, linked to tokens.css)
</success_criteria>

<output>
After completion, create `.planning/phases/05-export-reporting/05-04-SUMMARY.md`
</output>
