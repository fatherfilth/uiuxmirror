---
phase: 02-normalization-component-mining
plan: 03
type: execute
wave: 2
depends_on: ["02-01", "02-02"]
files_modified:
  - src/output/dtcg-formatter.ts
  - src/output/schema-validator.ts
  - src/output/index.ts
  - src/normalization/normalize-pipeline.ts
  - tests/output/dtcg-formatter.test.ts
autonomous: true

must_haves:
  truths:
    - "Normalized tokens are output in W3C Design Token Community Group format with $type and $value"
    - "Token groups are hierarchically organized (colors, typography, spacing, etc.)"
    - "uiux-mirror confidence and evidence metadata is stored in $extensions"
    - "Full normalization pipeline runs from raw PageTokens to validated DTCG output"
  artifacts:
    - path: "src/output/dtcg-formatter.ts"
      provides: "Transform normalized tokens to W3C DTCG format"
      exports: ["formatColorToken", "formatTypographyToken", "formatSpacingToken", "formatAllTokens"]
    - path: "src/output/schema-validator.ts"
      provides: "DTCG format validation"
      exports: ["validateDTCGOutput"]
    - path: "src/normalization/normalize-pipeline.ts"
      provides: "End-to-end normalization pipeline"
      exports: ["normalizePipeline", "NormalizationResult"]
  key_links:
    - from: "src/output/dtcg-formatter.ts"
      to: "src/normalization/color-normalizer.ts"
      via: "Formats ColorCluster into DTCG color tokens"
      pattern: "ColorCluster.*\\$type.*color"
    - from: "src/normalization/normalize-pipeline.ts"
      to: "src/normalization/index.ts"
      via: "Chains color normalizer -> unit normalizer -> cross-page validator -> scorer -> DTCG formatter"
      pattern: "deduplicateColors.*validateCrossPage.*formatAllTokens"
---

<objective>
Implement W3C DTCG output formatting and the full normalization pipeline that chains all Phase 2 normalization modules together: raw tokens -> deduplicate -> normalize units -> cross-page validate -> score -> format to DTCG.

Purpose: NORM-02 requires W3C DTCG format output. The normalization pipeline ties NORM-01, NORM-04, NORM-05 together into a usable workflow.
Output: DTCG formatter, schema validator, normalization pipeline, with tests.
</objective>

<execution_context>
@C:/Users/Karl/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Karl/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-normalization-component-mining/02-RESEARCH.md
@.planning/phases/02-normalization-component-mining/02-01-SUMMARY.md
@.planning/phases/02-normalization-component-mining/02-02-SUMMARY.md
@src/types/tokens.ts
@src/types/normalized-tokens.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement DTCG formatter and schema validator</name>
  <files>
    src/output/dtcg-formatter.ts
    src/output/schema-validator.ts
    src/output/index.ts
    tests/output/dtcg-formatter.test.ts
  </files>
  <action>
    1. Create `src/output/dtcg-formatter.ts`:
      - `interface DTCGToken`: { $type: string, $value: any, $description?: string, $extensions?: Record<string, any> }
      - `interface DTCGTokenFile`: Record<string, DTCGToken | DTCGTokenFile> (nested groups)
      - `formatColorToken(name: string, cluster: ColorCluster, confidence: ConfidenceScore): DTCGToken`
        - $type: 'color', $value: cluster.canonical (hex)
        - $description: "Appears on N elements across M pages"
        - $extensions['com.uiux-mirror']: { confidence: confidence.value, level: confidence.level, occurrences, variants, evidenceCount }
      - `formatTypographyToken(name: string, token: NormalizedTypographyToken, confidence: ConfidenceScore): DTCGToken`
        - $type: 'typography', $value: { fontFamily, fontSize (original), fontWeight, lineHeight, letterSpacing }
        - $extensions: confidence + normalizedSize in pixels
      - `formatSpacingToken(name: string, token: NormalizedSpacingToken, confidence: ConfidenceScore): DTCGToken`
        - $type: 'dimension', $value: token.value (original)
        - $extensions: confidence + normalizedValue in pixels
      - `formatRadiusToken`, `formatShadowToken`, `formatMotionToken` for remaining token types
        - Radii: $type 'dimension', Shadows: $type 'shadow', Motion: $type 'duration'/'cubicBezier'
      - `formatAllTokens(normalizedResult: NormalizationResult): DTCGTokenFile`
        - Organize into groups: { colors: {...}, typography: {...}, spacing: {...}, radii: {...}, shadows: {...}, motion: {...} }
        - Generate semantic names: color-1, color-2, heading-1, body-1, spacing-xs, spacing-sm, etc.
        - Name generation: sort by frequency/size, assign semantic labels

    2. Create `src/output/schema-validator.ts`:
      - `validateDTCGOutput(tokens: DTCGTokenFile): { valid: boolean, errors: string[] }`
        - Use zod schema to validate structure:
          - Every token node must have $type and $value
          - $type must be one of: 'color', 'dimension', 'typography', 'shadow', 'duration', 'cubicBezier', 'number'
          - Group nodes (no $type) must only contain token nodes or other group nodes
        - Note: Research suggested w3c-design-tokens-standard-schema npm package. Check if it exists and is compatible. If not, use custom zod schema based on W3C spec. Do NOT fail the plan if the npm package doesn't work -- fall back to custom validation.

    3. Create `src/output/index.ts` barrel export.

    4. Create `tests/output/dtcg-formatter.test.ts`:
      - Color token has correct $type 'color' and hex $value
      - Typography token has $type 'typography' with font properties in $value
      - Spacing token has $type 'dimension' with original value
      - Extensions include confidence score and occurrence data
      - formatAllTokens produces nested group structure
      - Validate output structure with validateDTCGOutput

    5. Run tests: `npx vitest run tests/output/`
  </action>
  <verify>`npx vitest run tests/output/` passes all tests. `npx tsc --noEmit` passes.</verify>
  <done>DTCG formatter produces valid W3C format tokens with confidence metadata in extensions</done>
</task>

<task type="auto">
  <name>Task 2: Build normalization pipeline and integrate all modules</name>
  <files>
    src/normalization/normalize-pipeline.ts
    src/normalization/index.ts
  </files>
  <action>
    1. Create `src/normalization/normalize-pipeline.ts`:
      - `interface NormalizationResult`:
        - colors: { clusters: ColorCluster[], standards: CrossPageResult<ColorCluster>[], all: CrossPageResult<ColorCluster>[] }
        - typography: { normalized: NormalizedTypographyToken[], standards: CrossPageResult<NormalizedTypographyToken>[], all: CrossPageResult<NormalizedTypographyToken>[] }
        - spacing: { normalized: NormalizedSpacingToken[], scale: SpacingScale, standards: CrossPageResult<NormalizedSpacingToken>[], all: CrossPageResult<NormalizedSpacingToken>[] }
        - radii: { standards: CrossPageResult<RadiusToken>[], all: CrossPageResult<RadiusToken>[] }
        - shadows: { standards: CrossPageResult<ShadowToken>[], all: CrossPageResult<ShadowToken>[] }
        - motion: { standards: CrossPageResult<MotionToken>[], all: CrossPageResult<MotionToken>[] }
        - dtcg: DTCGTokenFile
        - metadata: { totalPages: number, minPageThreshold: number, baseFontSize: number, timestamp: string }
      - `interface NormalizationOptions`: { minPageThreshold?: number, baseFontSize?: number, colorDistanceThreshold?: number }
      - `normalizePipeline(allPageTokens: Record<string, PageTokens>, options?: NormalizationOptions): NormalizationResult`
        Pipeline steps:
        a. Aggregate all tokens across pages (merge evidence)
        b. Deduplicate colors using CIEDE2000 (color-normalizer)
        c. Normalize typography and spacing units (unit-normalizer)
        d. Detect spacing scale (spacing-scale-detector)
        e. Run cross-page validation on all token types (cross-page-validator)
        f. Calculate confidence scores (token-scorer)
        g. Format to DTCG output (dtcg-formatter)
        h. Validate DTCG output (schema-validator)
        i. Return NormalizationResult with all intermediate data

    2. Update `src/normalization/index.ts` to export normalize-pipeline.

    3. Verify the full pipeline compiles: `npx tsc --noEmit`
  </action>
  <verify>`npx tsc --noEmit` passes. normalizePipeline function exists and chains all modules correctly.</verify>
  <done>Full normalization pipeline chains deduplication -> unit normalization -> cross-page validation -> confidence scoring -> DTCG formatting into a single callable function</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with zero errors
- `npx vitest run tests/output/ tests/normalization/` passes all tests
- DTCG output validates against W3C format requirements
- Normalization pipeline chains all modules in correct order
</verification>

<success_criteria>
- W3C DTCG format output with $type, $value, $description, $extensions
- Token groups organized hierarchically (colors.*, typography.*, spacing.*)
- Confidence metadata preserved in $extensions['com.uiux-mirror']
- Pipeline produces complete NormalizationResult from raw PageTokens input
</success_criteria>

<output>
After completion, create `.planning/phases/02-normalization-component-mining/02-03-SUMMARY.md`
</output>
