---
phase: 02-normalization-component-mining
plan: 05
type: execute
wave: 2
depends_on: ["02-04"]
files_modified:
  - src/components/variant-analyzer.ts
  - src/components/state-mapper.ts
  - src/types/components.ts
  - tests/components/variant-analyzer.test.ts
  - tests/components/state-mapper.test.ts
autonomous: true

must_haves:
  truths:
    - "Size variants (small/medium/large) are detected from padding distribution percentiles"
    - "Color emphasis variants (primary/secondary/tertiary) are detected from background color clustering"
    - "Hover state shows style differences from default (captured via Playwright .hover())"
    - "Focus state shows outline/ring differences from default (captured via Playwright .focus())"
    - "Disabled state detected via DOM attribute clone"
    - "States only recorded when they differ from the default state"
  artifacts:
    - path: "src/components/variant-analyzer.ts"
      provides: "Variant dimension detection per component type"
      exports: ["analyzeVariants", "ComponentVariant"]
    - path: "src/components/state-mapper.ts"
      provides: "Interactive state extraction via Playwright interaction"
      exports: ["mapComponentStates", "StateMapping"]
  key_links:
    - from: "src/components/variant-analyzer.ts"
      to: "src/types/components.ts"
      via: "DetectedComponent -> ComponentVariant analysis"
      pattern: "DetectedComponent.*ComponentVariant"
    - from: "src/components/state-mapper.ts"
      to: "playwright"
      via: "page.locator().hover() and .focus() for state triggering"
      pattern: "hover\\(\\)|focus\\(\\)"
---

<objective>
Implement component variant detection and interactive state mapping. Variant analysis identifies size, color, and emphasis dimensions. State mapper uses Playwright interactions to capture hover, focus, active, and disabled state styles.

Purpose: COMP-02 requires variant dimension detection. COMP-03 requires interactive state mapping per component.
Output: Variant analyzer, state mapper, with tests.
</objective>

<execution_context>
@C:/Users/Karl/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Karl/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-normalization-component-mining/02-RESEARCH.md
@.planning/phases/02-normalization-component-mining/02-04-SUMMARY.md
@src/types/components.ts
@src/components/component-detector.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement variant analyzer with percentile-based dimension detection</name>
  <files>
    src/components/variant-analyzer.ts
    src/types/components.ts
    tests/components/variant-analyzer.test.ts
  </files>
  <action>
    1. Update `src/types/components.ts` to add:
      - `interface ComponentVariant`: { size?: 'small' | 'medium' | 'large', emphasis?: 'primary' | 'secondary' | 'tertiary' | 'ghost', shape?: 'rounded' | 'pill' | 'square', evidence: TokenEvidence[] }
      - `interface VariantDimension`: { name: string, values: string[], distribution: Record<string, number> }
      - `interface AnalyzedComponent`: extends DetectedComponent with { variant: ComponentVariant, variantDimensions: VariantDimension[] }

    2. Create `src/components/variant-analyzer.ts`:
      - `analyzeVariants(components: DetectedComponent[]): AnalyzedComponent[]`
        - Group components by type
        - For each group, analyze variant dimensions:

      - **Size detection** (`detectSizeVariant`):
        - Collect paddingTop values from all instances
        - Use percentile-based clustering (not fixed thresholds, per research pitfall #6):
          - Calculate 33rd and 66th percentiles
          - Bottom third = 'small', middle third = 'medium', top third = 'large'
        - If fewer than 3 distinct padding values, use simple binning (< median = small, >= median = large)

      - **Emphasis detection** (`detectEmphasisVariant`):
        - Check backgroundColor: solid color (not transparent) = 'primary'
        - Border-only (transparent bg + visible border) = 'secondary'
        - Text-only (transparent bg, no border, just colored text) = 'ghost'
        - Everything else = 'tertiary'

      - **Shape detection** (`detectShapeVariant`):
        - borderRadius === '50%' or borderRadius > height/2 = 'pill'
        - borderRadius > 0 = 'rounded'
        - borderRadius === 0 = 'square'

      - Record distribution: count of each variant value across all instances

    3. Create `tests/components/variant-analyzer.test.ts`:
      - 3 buttons with padding 4, 8, 16 => small, medium, large
      - Button with solid bg => primary emphasis
      - Button with transparent bg + border => secondary emphasis
      - Button with borderRadius 50% => pill shape
      - Button with borderRadius 4px => rounded shape
      - Single component: no size distribution, keep raw value
      - Distribution counts are accurate

    4. Run tests: `npx vitest run tests/components/variant-analyzer`
  </action>
  <verify>`npx vitest run tests/components/variant-analyzer` passes all tests. `npx tsc --noEmit` passes.</verify>
  <done>Variant analyzer detects size (percentile-based), emphasis (bg/border heuristic), and shape (borderRadius) dimensions from component instances</done>
</task>

<task type="auto">
  <name>Task 2: Implement state mapper with Playwright interaction triggering</name>
  <files>
    src/components/state-mapper.ts
    tests/components/state-mapper.test.ts
  </files>
  <action>
    1. Create `src/components/state-mapper.ts`:
      - `interface StateMapping`: { default: Record<string, string>, hover?: Record<string, string>, focus?: Record<string, string>, active?: Record<string, string>, disabled?: Record<string, string> }
      - `interface StateDiff`: { property: string, defaultValue: string, stateValue: string }
      - Properties to track for state changes: backgroundColor, color, borderColor, opacity, cursor, outline, outlineColor, outlineWidth, boxShadow, transform, textDecoration

      - `mapComponentStates(page: Page, selector: string): Promise<StateMapping>`
        a. Get default state via page.evaluate() (string-based, inline):
           - Read all tracked properties via getComputedStyle
        b. Hover state:
           - `await page.locator(selector).hover()` wrapped in try/catch
           - Wait 150ms for transitions
           - Read tracked properties
           - Compare to default; only include if at least 1 property differs
        c. Focus state:
           - `await page.locator(selector).focus()` wrapped in try/catch
           - Wait 100ms
           - Read tracked properties
           - Compare to default; only include if at least 1 property differs
        d. Disabled state (for button, input, select only):
           - Use page.evaluate() to temporarily set disabled attribute, read styles, remove attribute
           - Compare to default
        e. For each state, return only properties that changed (diff)
        f. Move mouse away after hover to reset state: `await page.mouse.move(0, 0)`
        g. Blur after focus: `await page.evaluate(() => (document.activeElement as HTMLElement)?.blur())`
        h. Wrap entire function in try/catch -- if interaction fails, return default-only mapping

      - `mapAllComponentStates(page: Page, components: DetectedComponent[]): Promise<Map<string, StateMapping>>`
        - For each component, call mapComponentStates with its selector
        - Return Map<selector, StateMapping>
        - Limit to first 20 components per type to avoid spending too long on interaction

    2. Create `tests/components/state-mapper.test.ts`:
      - Unit tests for state diff detection:
        - Two identical style objects => no diff (empty state)
        - Default bg=#fff, hover bg=#eee => hover state includes backgroundColor
        - Default outline=none, focus outline=2px => focus state includes outline
      - Integration test concept (with Playwright):
        - Create fixture HTML with button that has :hover { background: red }
        - Verify hover state captured
        - NOTE: Full Playwright integration test may be deferred to 02-06

    3. Update `src/components/index.ts` to export variant-analyzer and state-mapper.

    4. Run tests: `npx vitest run tests/components/state-mapper`
  </action>
  <verify>`npx vitest run tests/components/` passes all tests. `npx tsc --noEmit` passes.</verify>
  <done>State mapper triggers hover/focus/disabled via Playwright interaction, captures only changed properties, limits to 20 components per type</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with zero errors
- `npx vitest run tests/components/` passes all tests
- Variant dimensions correctly detected from component instance distributions
- State mapping captures only properties that differ from default
</verification>

<success_criteria>
- Size variants use percentile-based clustering (not fixed thresholds)
- Emphasis variants detected from background/border/text styling patterns
- Hover, focus, disabled states captured via Playwright interaction
- States only recorded when at least one property differs from default
- State mapping is resilient (try/catch, never crashes pipeline)
</success_criteria>

<output>
After completion, create `.planning/phases/02-normalization-component-mining/02-05-SUMMARY.md`
</output>
