---
phase: 02-normalization-component-mining
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - package.json
  - src/normalization/color-normalizer.ts
  - src/normalization/unit-normalizer.ts
  - src/normalization/fuzzy-matcher.ts
  - src/normalization/index.ts
  - src/types/normalized-tokens.ts
  - tests/normalization/color-normalizer.test.ts
  - tests/normalization/unit-normalizer.test.ts
autonomous: true

must_haves:
  truths:
    - "Colors within CIEDE2000 threshold 2.3 are clustered into a single canonical color"
    - "All size units (rem, em, pt) are converted to px using detected or default base font size"
    - "Original units are preserved alongside normalized px values"
  artifacts:
    - path: "src/normalization/color-normalizer.ts"
      provides: "CIEDE2000 color clustering via culori"
      exports: ["deduplicateColors", "ColorCluster"]
    - path: "src/normalization/unit-normalizer.ts"
      provides: "Unit conversion (rem/em/pt to px)"
      exports: ["normalizeUnit", "NormalizedValue"]
    - path: "src/normalization/fuzzy-matcher.ts"
      provides: "Generic fuzzy matching utilities"
      exports: ["fuzzyMatchTokens"]
    - path: "src/types/normalized-tokens.ts"
      provides: "Type definitions for normalized tokens and clusters"
      exports: ["NormalizedColorToken", "NormalizedTypographyToken", "NormalizedSpacingToken", "TokenWithFrequency"]
  key_links:
    - from: "src/normalization/color-normalizer.ts"
      to: "culori"
      via: "differenceEuclidean('lab') for CIEDE2000 delta E"
      pattern: "differenceEuclidean.*lab"
    - from: "src/normalization/unit-normalizer.ts"
      to: "src/types/normalized-tokens.ts"
      via: "NormalizedValue type"
      pattern: "NormalizedValue"
---

<objective>
Implement token normalization foundations: CIEDE2000 color deduplication using culori, unit normalization (rem/em/pt to px), and fuzzy matching utilities. TDD approach ensures correctness of perceptual color distance and unit conversion math.

Purpose: NORM-01 requires fuzzy matching for deduplication. Color distance (CIEDE2000) and unit conversion are the two core algorithms everything else depends on.
Output: Color normalizer, unit normalizer, fuzzy matcher, normalized token types, with passing tests.
</objective>

<execution_context>
@C:/Users/Karl/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Karl/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-normalization-component-mining/02-RESEARCH.md
@src/types/tokens.ts
@src/types/evidence.ts
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install culori, create normalized token types, and write failing tests</name>
  <files>
    package.json
    src/types/normalized-tokens.ts
    tests/normalization/color-normalizer.test.ts
    tests/normalization/unit-normalizer.test.ts
  </files>
  <action>
    1. Install culori: `npm install culori` and `npm install -D @types/culori` (check if types are needed -- culori v4 ships its own types).

    2. Create `src/types/normalized-tokens.ts` with:
      - `NormalizedValue`: { pixels: number, original: string, unit: 'px' | 'rem' | 'em' | 'pt', baseFontSize?: number }
      - `ColorCluster`: { canonical: string, variants: string[], evidence: TokenEvidence[], occurrences: number }
      - `NormalizedColorToken`: extends ColorToken with { cluster: ColorCluster, confidence?: number }
      - `NormalizedTypographyToken`: extends TypographyToken with { normalizedSize: NormalizedValue }
      - `NormalizedSpacingToken`: extends SpacingToken with { normalizedValue: NormalizedValue }
      - `TokenWithFrequency<T>`: { token: T, pageUrls: Set<string>, occurrenceCount: number, confidence: number }

    3. Create `tests/normalization/color-normalizer.test.ts` with tests:
      - Colors with deltaE < 2.3 are clustered together (e.g., #3b82f6 and slightly shifted variant)
      - Colors with deltaE > 2.3 remain separate clusters
      - Single color produces one cluster with that color as canonical
      - Empty input returns empty array
      - Cluster canonical is the first (most frequent) color encountered
      - Evidence arrays are merged across clustered colors

    4. Create `tests/normalization/unit-normalizer.test.ts` with tests:
      - 16px with base 16 returns pixels: 16
      - 1rem with base 16 returns pixels: 16
      - 1.5rem with base 16 returns pixels: 24
      - 1em with parentFontSize 20 returns pixels: 20
      - 12pt returns pixels: 16 (12 * 96/72)
      - 0px returns pixels: 0
      - Invalid value throws error
      - Original value and unit preserved in output

    5. Run tests: `npx vitest run tests/normalization/` -- all must FAIL (RED).
  </action>
  <verify>`npx vitest run tests/normalization/` shows all tests failing (RED phase -- no implementation yet)</verify>
  <done>culori installed, normalized token types defined, test files written with meaningful RED failures</done>
</task>

<task type="auto">
  <name>Task 2: Implement color normalizer, unit normalizer, and fuzzy matcher (GREEN)</name>
  <files>
    src/normalization/color-normalizer.ts
    src/normalization/unit-normalizer.ts
    src/normalization/fuzzy-matcher.ts
    src/normalization/index.ts
  </files>
  <action>
    1. Create `src/normalization/color-normalizer.ts`:
      - Import `differenceEuclidean` and `converter` from culori
      - `deduplicateColors(colors: ColorToken[], threshold: number = 2.3): ColorCluster[]`
        - Create deltaE function using `differenceEuclidean('lab')` for CIEDE2000 in LAB space
        - Convert hex to RGB via culori's converter('rgb')
        - For each color, find existing cluster within threshold
        - If found, merge into cluster (add to variants array, merge evidence, increment occurrences)
        - If not found, create new cluster with color as canonical
        - Return sorted by occurrences descending
      - Handle edge cases: transparent colors, invalid hex, empty input

    2. Create `src/normalization/unit-normalizer.ts`:
      - `normalizeUnit(value: string, baseFontSize: number = 16, parentFontSize?: number): NormalizedValue`
        - Parse value string with regex: /^([\d.]+)(px|rem|em|pt|%)$/
        - Convert to pixels based on unit type:
          - px: direct
          - rem: num * baseFontSize
          - em: num * (parentFontSize ?? baseFontSize)
          - pt: num * (96 / 72)
        - Round to 2 decimal places
        - Return { pixels, original, unit, baseFontSize (for relative units) }
      - `normalizeSpacingValues(values: SpacingToken[], baseFontSize: number = 16): NormalizedSpacingToken[]`
        - Apply normalizeUnit to each spacing token's value
      - `normalizeTypographyValues(values: TypographyToken[], baseFontSize: number = 16): NormalizedTypographyToken[]`
        - Apply normalizeUnit to size field, preserve sizePixels from Phase 1

    3. Create `src/normalization/fuzzy-matcher.ts`:
      - `fuzzyMatchTokens<T>(tokens: T[], distanceFn: (a: T, b: T) => number, threshold: number): T[][]`
        - Generic clustering function using provided distance function and threshold
        - Returns array of groups (each group is array of similar tokens)
      - This enables future fuzzy matching beyond just colors (e.g., similar spacing values)

    4. Create `src/normalization/index.ts` barrel export for all normalizer modules.

    5. Run tests: `npx vitest run tests/normalization/` -- all must PASS (GREEN).
  </action>
  <verify>`npx vitest run tests/normalization/` shows all tests passing (GREEN phase)</verify>
  <done>Color deduplication clusters perceptually similar colors using CIEDE2000, unit normalizer converts all units to px while preserving originals, all tests pass</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with zero errors
- `npx vitest run tests/normalization/` passes all tests
- Color deduplication correctly groups similar colors (verified by test with known deltaE values)
- Unit normalization produces correct px values for all unit types
</verification>

<success_criteria>
- CIEDE2000-based color clustering works with threshold 2.3 (JND)
- rem/em/pt to px conversion is accurate with configurable base font size
- Original values and units preserved alongside normalized px
- All normalization code has passing tests
</success_criteria>

<output>
After completion, create `.planning/phases/02-normalization-component-mining/02-01-SUMMARY.md`
</output>
