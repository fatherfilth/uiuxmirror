---
phase: 02-normalization-component-mining
plan: 06
type: execute
wave: 3
depends_on: ["02-03", "02-05"]
files_modified:
  - src/scoring/component-scorer.ts
  - src/components/component-aggregator.ts
  - src/scoring/index.ts
  - src/components/index.ts
  - src/index.ts
  - tests/scoring/component-scorer.test.ts
  - tests/integration/phase2-pipeline.test.ts
autonomous: true

must_haves:
  truths:
    - "Component consistency score reflects cross-page frequency and variant uniformity"
    - "Components appearing on 3+ pages receive higher confidence than single-page components"
    - "Component aggregator merges instances across pages into canonical component definitions"
    - "Full Phase 2 pipeline (tokens + components) runs end-to-end from raw PageTokens + DOM data"
    - "All Phase 2 exports are accessible from src/index.ts"
  artifacts:
    - path: "src/scoring/component-scorer.ts"
      provides: "Component consistency scoring"
      exports: ["calculateComponentConfidence", "ComponentConfidenceScore"]
    - path: "src/components/component-aggregator.ts"
      provides: "Cross-page component aggregation and deduplication"
      exports: ["aggregateComponents", "AggregatedComponent"]
    - path: "tests/integration/phase2-pipeline.test.ts"
      provides: "Integration tests for complete Phase 2 pipeline"
  key_links:
    - from: "src/scoring/component-scorer.ts"
      to: "src/components/component-aggregator.ts"
      via: "Scorer uses aggregated component page count for confidence"
      pattern: "pageUrls.*totalPages"
    - from: "src/components/component-aggregator.ts"
      to: "src/components/variant-analyzer.ts"
      via: "Aggregator uses variant analysis to merge instances"
      pattern: "analyzeVariants.*AggregatedComponent"
    - from: "src/index.ts"
      to: "src/normalization/index.ts"
      via: "Re-exports all normalization modules"
      pattern: "export.*from.*normalization"
---

<objective>
Implement component consistency scoring, cross-page component aggregation, and integration tests validating the full Phase 2 pipeline. Wire all Phase 2 modules into src/index.ts.

Purpose: COMP-04 requires statistical confidence scoring for component consistency. Integration tests validate that NORM-01, NORM-02, NORM-04, NORM-05, COMP-01, COMP-02, COMP-03, COMP-04 all work together.
Output: Component scorer, component aggregator, integration tests, updated exports.
</objective>

<execution_context>
@C:/Users/Karl/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Karl/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-normalization-component-mining/02-RESEARCH.md
@.planning/phases/02-normalization-component-mining/02-03-SUMMARY.md
@.planning/phases/02-normalization-component-mining/02-05-SUMMARY.md
@src/types/components.ts
@src/types/tokens.ts
@src/normalization/normalize-pipeline.ts
@src/components/component-detector.ts
@src/components/variant-analyzer.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement component scorer and cross-page aggregator</name>
  <files>
    src/scoring/component-scorer.ts
    src/components/component-aggregator.ts
    src/scoring/index.ts
    src/components/index.ts
  </files>
  <action>
    1. Create `src/scoring/component-scorer.ts`:
      - `interface ComponentConfidenceScore`: { value: number, level: 'low' | 'medium' | 'high', pageCount: number, instanceCount: number, variantConsistency: number, reasoning: string }
      - `calculateComponentConfidence(component: AggregatedComponent, totalPages: number, minPageThreshold: number = 3): ComponentConfidenceScore`
        a. Page frequency: pageCount / totalPages (raw confidence)
        b. Instance density: min(instanceCount / (pageCount * 3), 0.15) -- density bonus capped at 0.15
        c. Variant consistency: 1 - (uniqueVariantCount / totalInstances). Higher when instances are uniform. If all instances have same variant = 1.0, all different = approaches 0.
        d. Combined: (0.5 * pageFrequency) + (0.3 * variantConsistency) + (0.2 * densityBonus), capped at 1.0
        e. Level: pageCount < minPageThreshold = 'low', value < 0.3 = 'low', value < 0.6 = 'medium', else 'high'
        f. Reasoning string includes pageCount, instanceCount, variantConsistency

    2. Create `src/components/component-aggregator.ts`:
      - `interface AggregatedComponent`: { type: ComponentType, instances: DetectedComponent[], pageUrls: Set<string>, variants: AnalyzedComponent[], states: StateMapping | null, confidence: ComponentConfidenceScore | null, canonical: { styles: Record<string, string>, variant: ComponentVariant } }
      - `aggregateComponents(perPageComponents: Map<string, DetectedComponent[]>, totalPages: number): AggregatedComponent[]`
        a. Collect all components across pages
        b. Group by type
        c. For each type group:
           - Collect all unique page URLs
           - Analyze variants across all instances (via analyzeVariants)
           - Determine canonical representation:
             - Most common variant (highest count in distribution)
             - Most common style values (mode of each CSS property)
           - Calculate confidence score
        d. Sort by confidence descending within each type
        e. Return flat array of AggregatedComponent

    3. Update `src/scoring/index.ts` to export component-scorer.

    4. Update `src/components/index.ts` to export component-aggregator.
  </action>
  <verify>`npx tsc --noEmit` passes with zero errors</verify>
  <done>Component scorer produces confidence based on page frequency + variant consistency + density. Aggregator merges per-page components into canonical definitions.</done>
</task>

<task type="auto">
  <name>Task 2: Write integration tests and wire Phase 2 exports</name>
  <files>
    tests/scoring/component-scorer.test.ts
    tests/integration/phase2-pipeline.test.ts
    src/index.ts
  </files>
  <action>
    1. Create `tests/scoring/component-scorer.test.ts`:
      - Component on 10/20 pages with uniform variants => high confidence
      - Component on 2/20 pages => low confidence (below threshold)
      - Component on 5/20 pages with 5 different variants => medium confidence (mixed: good page count, low consistency)
      - Variant consistency: 10 instances all same variant = 1.0
      - Variant consistency: 10 instances all different variant approaches 0
      - Reasoning string includes page count and instance count

    2. Create `tests/integration/phase2-pipeline.test.ts`:
      - Test normalization pipeline with mock data:
        a. Create mock PageTokens for 5 pages with overlapping colors, typography, spacing
        b. Run normalizePipeline(allPageTokens)
        c. Verify: colors are deduplicated (similar hex values merged)
        d. Verify: cross-page validation filters tokens below threshold
        e. Verify: confidence scores assigned to all tokens
        f. Verify: DTCG output has correct $type and $value structure
        g. Verify: metadata includes totalPages and timestamp
      - Test component aggregation with mock data:
        a. Create mock DetectedComponent arrays for 4 pages
        b. Run aggregateComponents
        c. Verify: components grouped by type
        d. Verify: page URLs collected correctly
        e. Verify: confidence scores assigned
      - These tests use MOCK DATA (not Playwright) to validate logic flow

    3. Update `src/index.ts` to re-export all Phase 2 modules:
      - `export * from './normalization/index.js'`
      - `export * from './components/index.js'`
      - `export * from './scoring/index.js'`
      - `export * from './output/index.js'`
      - `export * from './types/components.js'`
      - `export * from './types/normalized-tokens.js'`

    4. Run all Phase 2 tests: `npx vitest run tests/`
  </action>
  <verify>`npx vitest run tests/` passes ALL tests (Phase 1 + Phase 2). `npx tsc --noEmit` passes.</verify>
  <done>Component scoring validates cross-page consistency. Integration tests verify full pipeline with mock data. All Phase 2 exports accessible from src/index.ts.</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with zero errors
- `npx vitest run tests/` passes ALL tests (existing Phase 1 tests still pass)
- Component confidence scores correctly combine page frequency and variant consistency
- Integration test demonstrates full normalization + component pipeline flow
- All Phase 2 modules exportable from src/index.ts
</verification>

<success_criteria>
- Component confidence scoring combines page frequency (50%), variant consistency (30%), and density (20%)
- Cross-page aggregation merges per-page component instances into canonical definitions
- Integration tests validate end-to-end: raw tokens -> normalized -> scored -> DTCG formatted
- No regressions in Phase 1 tests
- All Phase 2 code accessible via src/index.ts
</success_criteria>

<output>
After completion, create `.planning/phases/02-normalization-component-mining/02-06-SUMMARY.md`
</output>
