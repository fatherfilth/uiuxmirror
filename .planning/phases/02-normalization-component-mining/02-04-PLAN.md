---
phase: 02-normalization-component-mining
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types/components.ts
  - src/components/component-detector.ts
  - src/components/signatures/button-signature.ts
  - src/components/signatures/input-signature.ts
  - src/components/signatures/card-signature.ts
  - src/components/signatures/nav-signature.ts
  - src/components/signatures/modal-signature.ts
  - src/components/signatures/index.ts
  - src/components/index.ts
  - tests/components/component-detector.test.ts
autonomous: true

must_haves:
  truths:
    - "Buttons are detected via tag name, ARIA role, or styled-link heuristic"
    - "Inputs are detected via tag name, ARIA role, or contenteditable"
    - "Cards are detected via structural heuristic (background + padding + border-radius + children)"
    - "Navigation is detected via nav tag or ARIA role"
    - "Modals are detected via ARIA role dialog/alertdialog or structural heuristic"
    - "Each detected component includes evidence (page URL, selector, computed styles)"
  artifacts:
    - path: "src/types/components.ts"
      provides: "Component type definitions"
      exports: ["DetectedComponent", "ComponentType", "ComponentSignature", "ElementData"]
    - path: "src/components/component-detector.ts"
      provides: "Main detection orchestrator"
      exports: ["detectComponents"]
    - path: "src/components/signatures/button-signature.ts"
      provides: "Button detection heuristic"
      exports: ["BUTTON_SIGNATURE"]
  key_links:
    - from: "src/components/component-detector.ts"
      to: "src/components/signatures/index.ts"
      via: "Loads all signatures and applies to page elements"
      pattern: "ALL_SIGNATURES.*match"
    - from: "src/components/component-detector.ts"
      to: "src/extractors/shared/style-utils.ts"
      via: "Reuses getAllVisibleElements for element scanning"
      pattern: "getAllVisibleElements"
---

<objective>
Implement multi-signal component detection from DOM structures. Identifies 5 component types (buttons, inputs, cards, nav, modals) using tag names, ARIA roles, and CSS property heuristics.

Purpose: COMP-01 requires identifying common components from DOM signatures. Multi-signal detection (tag + ARIA + CSS) ensures coverage of custom components.
Output: Component type definitions, 5 signature matchers, detection orchestrator, with tests.
</objective>

<execution_context>
@C:/Users/Karl/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Karl/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-normalization-component-mining/02-RESEARCH.md
@src/types/tokens.ts
@src/types/evidence.ts
@src/extractors/shared/style-utils.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define component types and implement 5 signature matchers</name>
  <files>
    src/types/components.ts
    src/components/signatures/button-signature.ts
    src/components/signatures/input-signature.ts
    src/components/signatures/card-signature.ts
    src/components/signatures/nav-signature.ts
    src/components/signatures/modal-signature.ts
    src/components/signatures/index.ts
  </files>
  <action>
    1. Create `src/types/components.ts`:
      - `type ComponentType = 'button' | 'input' | 'card' | 'nav' | 'modal'`
      - `interface ElementData`: { tagName: string, role?: string, computedStyles: Record<string, string>, textContent: string, hasChildren: boolean, childCount: number, selector: string, attributes: Record<string, string> }
      - `interface ComponentSignature`: { type: ComponentType, match(element: ElementData): boolean, priority: number }
        - Priority determines which signature wins if element matches multiple (higher = wins)
      - `interface DetectedComponent`: { type: ComponentType, selector: string, element: ElementData, evidence: TokenEvidence[], computedStyles: Record<string, string>, pageUrl: string }
      - `interface ComponentInstance`: extends DetectedComponent with { variants?: Record<string, string>, states?: Record<string, Record<string, string>> }

    2. Create `src/components/signatures/button-signature.ts`:
      - BUTTON_SIGNATURE implements ComponentSignature with priority 10
      - match() returns true for:
        a. tagName === 'button'
        b. role === 'button'
        c. tagName === 'a' AND has button-like styling: paddingTop >= 6px AND paddingLeft >= 12px AND borderRadius > 0px AND (backgroundColor !== transparent OR border !== 'none')
        d. tagName === 'input' AND type in ['submit', 'button', 'reset']
      - Exclude: tagName === 'a' with display === 'inline' and no padding (regular links)

    3. Create `src/components/signatures/input-signature.ts`:
      - INPUT_SIGNATURE implements ComponentSignature with priority 10
      - match() returns true for:
        a. tagName in ['input', 'textarea', 'select'] (exclude type='submit'/'button'/'reset'/'hidden')
        b. role in ['textbox', 'combobox', 'searchbox', 'spinbutton', 'listbox']
        c. attributes.contenteditable === 'true'

    4. Create `src/components/signatures/card-signature.ts`:
      - CARD_SIGNATURE implements ComponentSignature with priority 5
      - match() returns true for:
        a. Has background color (not transparent) AND padding >= 12px AND borderRadius > 0 AND childCount >= 2
        b. OR role === 'article' with children
        c. OR tagName === 'article' with children
      - Exclude elements that are too small (width < 100px or height < 80px via bounding box if available)

    5. Create `src/components/signatures/nav-signature.ts`:
      - NAV_SIGNATURE implements ComponentSignature with priority 10
      - match() returns true for:
        a. tagName === 'nav'
        b. role === 'navigation'
        c. role === 'menubar'
        d. Element contains 3+ links (detected from children having tagName 'a' -- this check happens in detector, not signature)

    6. Create `src/components/signatures/modal-signature.ts`:
      - MODAL_SIGNATURE implements ComponentSignature with priority 10
      - match() returns true for:
        a. role in ['dialog', 'alertdialog']
        b. attributes['aria-modal'] === 'true'
        c. Structural heuristic: position fixed/absolute AND zIndex > 100 AND width > 200px AND height > 200px

    7. Create `src/components/signatures/index.ts`:
      - Export ALL_SIGNATURES array containing all 5 signatures
      - Export each signature individually
  </action>
  <verify>`npx tsc --noEmit` passes with zero errors</verify>
  <done>5 component signatures defined with multi-signal detection (tag + ARIA + CSS heuristics)</done>
</task>

<task type="auto">
  <name>Task 2: Build component detector orchestrator and tests</name>
  <files>
    src/components/component-detector.ts
    src/components/index.ts
    tests/components/component-detector.test.ts
  </files>
  <action>
    1. Create `src/components/component-detector.ts`:
      - `detectComponents(page: Page, pageUrl: string): Promise<DetectedComponent[]>`
        a. Use page.evaluate() with string-based function (avoid __name issue from Phase 1) to scan all visible elements and extract ElementData:
           - tagName, role (getAttribute('role')), textContent (trimmed, max 100 chars), hasChildren, childCount, selector (reuse buildSelector logic inline), computed styles (background, padding, border, borderRadius, position, zIndex, display, width, height, cursor), attributes (type, contenteditable, aria-modal, aria-expanded, aria-haspopup, href)
        b. Import ALL_SIGNATURES from signatures/index
        c. For each element, test against all signatures
        d. If multiple signatures match, use highest priority
        e. Create DetectedComponent with evidence (pageUrl, selector, timestamp, computedStyles)
        f. Log count of detected components per type
        g. Limit element scanning to 500 elements (same as Phase 1 style-utils)
        h. Wrap in try/catch -- never crash the pipeline

    2. Create `src/components/index.ts` barrel export.

    3. Create `tests/components/component-detector.test.ts`:
      - Test each signature's match function directly with mock ElementData:
        a. Button: native button, role=button, styled link, regular link (should NOT match)
        b. Input: native input, textarea, select, role=textbox, hidden input (should NOT match)
        c. Card: div with bg + padding + radius + children, flat div (should NOT match)
        d. Nav: nav tag, role=navigation
        e. Modal: role=dialog, aria-modal=true
      - Test priority: element matching both card and button should resolve to button (higher priority)
      - Test empty page returns empty array

    4. Run tests: `npx vitest run tests/components/`
  </action>
  <verify>`npx vitest run tests/components/` passes all tests. `npx tsc --noEmit` passes.</verify>
  <done>Component detector scans DOM elements via Playwright, applies 5 signatures with priority resolution, returns typed DetectedComponent array with evidence</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with zero errors
- `npx vitest run tests/components/` passes all tests
- All 5 component types detected via multi-signal heuristics
- Evidence attached to every detected component
</verification>

<success_criteria>
- Buttons detected via <button>, role="button", and styled <a> tags
- Inputs detected via <input>, <textarea>, <select>, and ARIA roles
- Cards detected via background + padding + border-radius + children heuristic
- Navigation detected via <nav>, role="navigation"
- Modals detected via role="dialog" and structural heuristic
- Each component has evidence tracing (pageUrl, selector, computedStyles)
</success_criteria>

<output>
After completion, create `.planning/phases/02-normalization-component-mining/02-04-SUMMARY.md`
</output>
