---
phase: 06-cli-mcp-integration
plan: 04
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - src/mcp/server.ts
  - src/mcp/resources.ts
  - src/mcp/tools.ts
  - src/cli/commands/mcp.ts
autonomous: true

must_haves:
  truths:
    - "MCP server starts via stdio transport and completes JSON-RPC handshake with clients"
    - "Resources expose design tokens, components, and patterns as read-only queryable data"
    - "Tools expose component synthesis and format export as callable actions"
    - "All logging uses stderr (never stdout) to avoid corrupting stdio JSON-RPC"
  artifacts:
    - path: "src/mcp/server.ts"
      provides: "MCP server setup with stdio transport and capability registration"
      exports: ["createMcpServer", "startMcpServer"]
    - path: "src/mcp/resources.ts"
      provides: "MCP resource handlers for tokens, components, patterns, content style"
      exports: ["registerResources"]
    - path: "src/mcp/tools.ts"
      provides: "MCP tool handlers for synthesis and export"
      exports: ["registerTools"]
    - path: "src/cli/commands/mcp.ts"
      provides: "CLI command to start MCP server"
      exports: ["mcpCommand"]
  key_links:
    - from: "src/mcp/server.ts"
      to: "@modelcontextprotocol/sdk"
      via: "imports McpServer and StdioServerTransport"
      pattern: "import.*McpServer.*from.*@modelcontextprotocol/sdk"
    - from: "src/mcp/resources.ts"
      to: "src/export/formatters/json-layers.ts"
      via: "loads token/component/pattern JSON for resource responses"
      pattern: "import.*generate.*JSON"
    - from: "src/mcp/tools.ts"
      to: "src/synthesis/component-composer.ts"
      via: "calls synthesizeComponent for synthesis tool"
      pattern: "import.*synthesizeComponent"
    - from: "src/cli/commands/mcp.ts"
      to: "src/mcp/server.ts"
      via: "starts MCP server via startMcpServer"
      pattern: "import.*startMcpServer"
---

<objective>
Implement the MCP server that exposes design DNA as queryable resources and actionable tools for AI agents.

Purpose: AI agents (Claude Desktop, Cursor, etc.) can query extracted design DNA and synthesize components through the standardized MCP protocol.
Output: Working MCP server with resources for read-only data and tools for actions
</objective>

<execution_context>
@C:/Users/Karl/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Karl/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-cli-mcp-integration/06-RESEARCH.md
@.planning/phases/06-cli-mcp-integration/06-01-SUMMARY.md
@src/export/export-orchestrator.ts
@src/synthesis/component-composer.ts
@src/export/formatters/json-layers.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create MCP server with resources and tools</name>
  <files>src/mcp/server.ts, src/mcp/resources.ts, src/mcp/tools.ts</files>
  <action>
First, install `@modelcontextprotocol/sdk`: `npm install @modelcontextprotocol/sdk`
(zod is already installed as a dependency)

**Create `src/mcp/resources.ts`:**

Export `registerResources(server: McpServer, dataDir: string)` function that registers these MCP resources:

1. **`design-tokens`** — Returns normalized design tokens in DTCG format
   - Description: "Normalized design tokens extracted from the crawled site (colors, typography, spacing, etc.)"
   - mimeType: "application/json"
   - Handler: Read `{dataDir}/tokens.json`, return as text content. If file not found, return error message "No token data available. Run `uidna crawl` and `uidna extract` first."

2. **`components`** — Returns detected component catalog
   - Description: "Component patterns detected from the crawled site (buttons, inputs, cards, nav, modals)"
   - mimeType: "application/json"
   - Handler: Read `{dataDir}/components.json`, return as text content

3. **`patterns`** — Returns interaction flow patterns
   - Description: "Cross-page interaction patterns and content style rules"
   - mimeType: "application/json"
   - Handler: Read `{dataDir}/patterns.json`, return as text content

4. **`content-style`** — Returns content style analysis
   - Description: "Voice/tone, capitalization rules, CTA hierarchy, and error message grammar"
   - mimeType: "application/json"
   - Handler: Read `{dataDir}/content_style.json`, return as text content

5. **`brand-report`** — Returns the Brand DNA Report markdown
   - Description: "Human-readable Brand DNA Report summarizing the complete design system"
   - mimeType: "text/markdown"
   - Handler: Read `{dataDir}/exports/brand-dna-report.md`, return as text content

Use `readFile` from `fs/promises` for file reading. Use `console.error()` for all logging (NEVER console.log — corrupts stdio JSON-RPC). Wrap file reads in try/catch and return descriptive error messages when data is not available.

**Create `src/mcp/tools.ts`:**

Export `registerTools(server: McpServer, dataDir: string)` function that registers these MCP tools:

1. **`synthesize_component`** — Synthesize a new component
   - Description: "Synthesize a new component using extracted design DNA as constraints"
   - Input schema (zod): `{ component_type: z.string().describe("Component to synthesize, e.g. data-table, modal, tabs") }`
   - Handler:
     1. Load design DNA from dataDir JSON files
     2. Call `synthesizeComponent(component_type, designDNA)`
     3. Return JSON result with HTML, CSS, states, evidence, confidence
   - On error: return error message (don't throw)

2. **`export_format`** — Export tokens in a specific format
   - Description: "Export design tokens in a specified format"
   - Input schema (zod): `{ format: z.enum(["css", "tailwind", "figma", "json"]).describe("Export format") }`
   - Handler:
     1. Load normalized tokens from dataDir
     2. Call appropriate generator based on format
     3. Return generated content as text
   - On error: return error message

3. **`get_token`** — Look up a specific token by name or type
   - Description: "Look up specific design tokens by name or type"
   - Input schema (zod): `{ query: z.string().describe("Token name or type to search for, e.g. 'primary' or 'color'") }`
   - Handler:
     1. Load tokens.json
     2. Search quick layer for matching token names/types
     3. Return matching tokens

For all tools: Wrap handlers in try/catch. On error, return `{ content: [{ type: "text", text: "Error: {message}" }] }`. Use `console.error()` for logging.

**Create `src/mcp/server.ts`:**

Export `createMcpServer(dataDir: string): McpServer`:
1. Create McpServer with `{ name: "uidna", version: "0.1.0" }`
2. Call `registerResources(server, dataDir)`
3. Call `registerTools(server, dataDir)`
4. Return server

Export `startMcpServer(dataDir: string): Promise<void>`:
1. Call `createMcpServer(dataDir)`
2. Create `StdioServerTransport`
3. Call `server.connect(transport)`
4. Log to stderr: "UIUX-Mirror MCP server started (stdio mode)"

Import from `@modelcontextprotocol/sdk/server/mcp.js` and `@modelcontextprotocol/sdk/server/stdio.js`.
  </action>
  <verify>Run `npx tsc --noEmit` to confirm no type errors. Verify @modelcontextprotocol/sdk is in package.json dependencies.</verify>
  <done>MCP server registers 5 resources (tokens, components, patterns, content-style, brand-report) and 3 tools (synthesize_component, export_format, get_token) with proper error handling and stderr-only logging.</done>
</task>

<task type="auto">
  <name>Task 2: Create MCP CLI command and wire into router</name>
  <files>src/cli/commands/mcp.ts, src/cli.ts</files>
  <action>
**Create `src/cli/commands/mcp.ts`:**

Export `mcpCommand(args: string[])` async function:

1. Parse flags:
   - `--data-dir <dir>` (string, optional, default ".uidna")
   - `--help` (print mcp help and exit)

2. If `--help`, print:
   ```
   Usage: uidna mcp [options]

   Start MCP server for AI agent integration (stdio transport).

   The MCP server exposes design DNA as queryable resources and tools.
   Configure your MCP client (e.g., Claude Desktop) to launch:
     node dist/cli.js mcp

   Resources (read-only data):
     design-tokens     Normalized design tokens (colors, typography, spacing)
     components        Detected component patterns
     patterns          Interaction flow patterns
     content-style     Voice/tone, capitalization, CTA hierarchy
     brand-report      Brand DNA Report (markdown)

   Tools (actions):
     synthesize_component  Synthesize a new component
     export_format         Export tokens in css/tailwind/figma/json format
     get_token             Look up specific tokens by name or type

   Options:
     --data-dir <dir>  Data directory (default: .uidna)
   ```

3. IMPORTANT: Do NOT use console.log() for any output once the server starts. Only console.error() is safe.

4. Log startup to stderr: `console.error("Starting UIUX-Mirror MCP server...")`

5. Call `startMcpServer(dataDir)` from `../../mcp/server.js`

6. The server runs indefinitely (stdio blocks on stdin). No explicit keep-alive needed -- the SDK handles the event loop.

**Update `src/cli.ts`:**
- Wire the `mcp` case: `const { mcpCommand } = await import('./cli/commands/mcp.js'); await mcpCommand(process.argv.slice(3));`
  </action>
  <verify>Run `npx tsc --noEmit` to confirm no type errors. Run `npx tsx src/cli.ts mcp --help` to see MCP help text. Verify that starting MCP server without `--help` logs to stderr only (test briefly, then kill with Ctrl+C).</verify>
  <done>MCP server can be started via `uidna mcp` command and integrates with CLI router. Help text documents available resources and tools.</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes
- `uidna mcp --help` shows MCP help with resource and tool descriptions
- MCP server starts without errors (log to stderr)
- No console.log() calls exist in any MCP module (grep confirms)
- @modelcontextprotocol/sdk installed in package.json
</verification>

<success_criteria>
- MCP server registers all resources (tokens, components, patterns, content-style, brand-report)
- MCP server registers all tools (synthesize_component, export_format, get_token)
- Server uses stdio transport compatible with Claude Desktop and other MCP clients
- All logging uses stderr to preserve JSON-RPC protocol integrity
- CLI `uidna mcp` command starts server with proper help documentation
</success_criteria>

<output>
After completion, create `.planning/phases/06-cli-mcp-integration/06-04-SUMMARY.md`
</output>
