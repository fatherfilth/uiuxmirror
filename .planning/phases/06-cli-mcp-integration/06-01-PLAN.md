---
phase: 06-cli-mcp-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/cli/config-loader.ts
  - src/cli/progress.ts
  - src/cli.ts
autonomous: true

must_haves:
  truths:
    - "uidna.config.json in project root is loaded and merged with CLI flag overrides"
    - "CLI router dispatches to correct subcommand handler based on first argument"
    - "Progress spinner shows status during long operations and handles success/failure"
  artifacts:
    - path: "src/cli/config-loader.ts"
      provides: "Configuration loading from uidna.config.json with CLI override merging"
      exports: ["loadFullConfig", "UidnaConfigSchema"]
    - path: "src/cli/progress.ts"
      provides: "Ora-based progress spinner utility"
      exports: ["withProgress"]
    - path: "src/cli.ts"
      provides: "Refactored CLI entry point with subcommand routing"
      contains: "switch.*command"
  key_links:
    - from: "src/cli/config-loader.ts"
      to: "src/shared/config.ts"
      via: "imports loadConfig for merging defaults"
      pattern: "import.*loadConfig.*from.*shared/config"
    - from: "src/cli.ts"
      to: "src/cli/config-loader.ts"
      via: "uses loadFullConfig for all commands"
      pattern: "import.*loadFullConfig.*from.*cli/config-loader"
---

<objective>
Create the CLI foundation: config file loading, subcommand router, and progress feedback utility.

Purpose: All Phase 6 CLI commands and MCP server depend on configuration loading and the CLI router. This plan establishes the shared infrastructure.
Output: Config loader, progress utility, refactored CLI entry point with subcommand dispatch
</objective>

<execution_context>
@C:/Users/Karl/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Karl/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-cli-mcp-integration/06-RESEARCH.md
@src/cli.ts
@src/shared/config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create config loader and progress utility</name>
  <files>src/cli/config-loader.ts, src/cli/progress.ts</files>
  <action>
Create `src/cli/config-loader.ts`:
- Define `UidnaConfigSchema` using zod to validate `uidna.config.json` contents. Fields: maxDepth (int 1-10), maxPages (int 1-10000), domainAllowlist (string[]), respectRobotsTxt (boolean), viewportSizes (array of {width, height}), outputDir (string), maxConcurrency (int 1-20). All optional with no defaults (defaults come from shared/config.ts loadConfig).
- Export `loadFullConfig(cliArgs: Partial<CrawlConfig>)` function:
  1. Check if `uidna.config.json` exists in cwd using `existsSync`
  2. If exists, read with `readFile`, parse JSON, validate with `UidnaConfigSchema.parse()`
  3. Merge: fileConfig spread first, then cliArgs spread on top (CLI overrides file)
  4. Pass merged object to existing `loadConfig()` from `../shared/config.js` for final validation and defaults
  5. Return validated CrawlConfig
- If `uidna.config.json` has invalid JSON or fails zod validation, throw descriptive error with field details

Create `src/cli/progress.ts`:
- Install `ora` (already in research): `npm install ora`
- Export `withProgress<T>(message: string, task: (update: (text: string) => void) => Promise<T>): Promise<T>`
  1. Create ora spinner with initial message, call `.start()`
  2. Pass update function that sets `spinner.text`
  3. On success: call `spinner.succeed()`, return result
  4. On error: call `spinner.fail()`, rethrow error
- Export `createSpinner(message: string)` that returns raw ora spinner for commands needing more control (e.g., multi-phase operations)

Import ora as default import: `import ora from 'ora'` (ESM package).
  </action>
  <verify>Run `npx tsc --noEmit` and confirm no type errors in the new files. Verify ora is in package.json dependencies.</verify>
  <done>Config loader reads uidna.config.json, validates with zod, merges with CLI args, and delegates to existing loadConfig. Progress utility wraps ora for spinner feedback.</done>
</task>

<task type="auto">
  <name>Task 2: Refactor CLI entry point with subcommand routing</name>
  <files>src/cli.ts</files>
  <action>
Refactor `src/cli.ts` from the current single-command "uidna <url>" format to a subcommand router "uidna <command> [args]".

The refactored CLI entry point should:
1. Extract `command = process.argv[2]` as the subcommand
2. Keep the existing `parseArgs` function but rename to `parseFlags` and have it parse everything after the subcommand (`process.argv.slice(3)`)
3. Add a `switch(command)` dispatcher with cases for: `crawl`, `extract`, `report`, `synth`, `export`, `mcp`. Each case imports and calls the handler lazily (dynamic import) from `./cli/commands/{command}.js` to avoid loading unnecessary modules. For now, each case should print `"Command '{command}' not yet implemented"` and exit(0) since the actual handlers are built in plans 02-04.
4. Default case + `--help`/`-h` + no args: call `printUsage()`
5. Update `printUsage()` to show the new subcommand format:
   ```
   Usage: uidna <command> [options]

   Commands:
     crawl <url>          Crawl a website and extract design tokens
     extract              Run extraction pipeline on crawled data
     report               Generate Brand DNA Report
     synth <component>    Synthesize a new component using design DNA
     export               Export design tokens in various formats
     mcp                  Start MCP server for AI agent integration

   Options:
     --help, -h           Show help for a command
     --version            Show version number

   Run 'uidna <command> --help' for command-specific options.
   ```
6. Add `--version` flag that reads version from package.json (use `createRequire` or hardcode `0.1.0` for now)
7. Wrap the main switch in try/catch. On error: print error message to stderr, print stack trace if `LOG_LEVEL=debug`, exit(1).
8. Keep the shebang `#!/usr/bin/env node` at top

Update `package.json` bin entry to point to `./dist/cli.js` (currently incorrectly points to `./dist/index.js`).
  </action>
  <verify>Run `npx tsc --noEmit` to confirm no type errors. Run `npx tsx src/cli.ts --help` and verify the new usage message prints. Run `npx tsx src/cli.ts crawl` and verify "Command 'crawl' not yet implemented" output. Run `npx tsx src/cli.ts --version` and verify version prints.</verify>
  <done>CLI entry point dispatches to subcommands, shows proper usage, handles --help and --version flags, and is ready for command handlers in plans 02-04.</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with no errors
- `npx tsx src/cli.ts --help` shows subcommand usage
- `npx tsx src/cli.ts --version` shows version
- `npx tsx src/cli.ts crawl` shows placeholder message
- `npx tsx src/cli.ts unknown-cmd` shows usage and exits with code 1
- `uidna.config.json` loading tested by creating temp config and importing config-loader
</verification>

<success_criteria>
- Config loader reads uidna.config.json with zod validation and merges with CLI overrides
- CLI router dispatches crawl/extract/report/synth/export/mcp subcommands
- Progress utility wraps ora for spinner feedback
- All commands show placeholder messages ready for plan 02-04 implementation
</success_criteria>

<output>
After completion, create `.planning/phases/06-cli-mcp-integration/06-01-SUMMARY.md`
</output>
